var xe=Object.defineProperty,ke=Object.defineProperties;var Se=Object.getOwnPropertyDescriptors;var he=Object.getOwnPropertySymbols;var Ie=Object.prototype.hasOwnProperty,ve=Object.prototype.propertyIsEnumerable;var de=(t,e,r)=>e in t?xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,M=(t,e)=>{for(var r in e||(e={}))Ie.call(e,r)&&de(t,r,e[r]);if(he)for(var r of he(e))ve.call(e,r)&&de(t,r,e[r]);return t},Z=(t,e)=>ke(t,Se(e));function noop$2(){}function run(t){return t()}function blank_object(){return Object.create(null)}function run_all(t){t.forEach(run)}function is_function(t){return typeof t=="function"}function safe_not_equal(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}let src_url_equal_anchor;function src_url_equal(t,e){return src_url_equal_anchor||(src_url_equal_anchor=document.createElement("a")),src_url_equal_anchor.href=e,t===src_url_equal_anchor.href}function is_empty(t){return Object.keys(t).length===0}function append(t,e){t.appendChild(e)}function insert(t,e,r){t.insertBefore(e,r||null)}function detach(t){t.parentNode.removeChild(t)}function element(t){return document.createElement(t)}function text(t){return document.createTextNode(t)}function space(){return text(" ")}function attr(t,e,r){r==null?t.removeAttribute(e):t.getAttribute(e)!==r&&t.setAttribute(e,r)}function children(t){return Array.from(t.childNodes)}let current_component;function set_current_component(t){current_component=t}const dirty_components=[],binding_callbacks=[],render_callbacks=[],flush_callbacks=[],resolved_promise=Promise.resolve();let update_scheduled=!1;function schedule_update(){update_scheduled||(update_scheduled=!0,resolved_promise.then(flush$1))}function add_render_callback(t){render_callbacks.push(t)}const seen_callbacks=new Set;let flushidx=0;function flush$1(){const t=current_component;do{for(;flushidx<dirty_components.length;){const e=dirty_components[flushidx];flushidx++,set_current_component(e),update(e.$$)}for(set_current_component(null),dirty_components.length=0,flushidx=0;binding_callbacks.length;)binding_callbacks.pop()();for(let e=0;e<render_callbacks.length;e+=1){const r=render_callbacks[e];seen_callbacks.has(r)||(seen_callbacks.add(r),r())}render_callbacks.length=0}while(dirty_components.length);for(;flush_callbacks.length;)flush_callbacks.pop()();update_scheduled=!1,seen_callbacks.clear(),set_current_component(t)}function update(t){if(t.fragment!==null){t.update(),run_all(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(add_render_callback)}}const outroing=new Set;function transition_in(t,e){t&&t.i&&(outroing.delete(t),t.i(e))}function mount_component(t,e,r,n){const{fragment:o,on_mount:s,on_destroy:u,after_update:l}=t.$$;o&&o.m(e,r),n||add_render_callback(()=>{const h=s.map(run).filter(is_function);u?u.push(...h):run_all(h),t.$$.on_mount=[]}),l.forEach(add_render_callback)}function destroy_component(t,e){const r=t.$$;r.fragment!==null&&(run_all(r.on_destroy),r.fragment&&r.fragment.d(e),r.on_destroy=r.fragment=null,r.ctx=[])}function make_dirty(t,e){t.$$.dirty[0]===-1&&(dirty_components.push(t),schedule_update(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function init(t,e,r,n,o,s,u,l=[-1]){const h=current_component;set_current_component(t);const d=t.$$={fragment:null,ctx:null,props:s,update:noop$2,not_equal:o,bound:blank_object(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(h?h.$$.context:[])),callbacks:blank_object(),dirty:l,skip_bound:!1,root:e.target||h.$$.root};u&&u(d.root);let p=!1;if(d.ctx=r?r(t,e.props||{},(b,_,...T)=>{const C=T.length?T[0]:_;return d.ctx&&o(d.ctx[b],d.ctx[b]=C)&&(!d.skip_bound&&d.bound[b]&&d.bound[b](C),p&&make_dirty(t,b)),_}):[],d.update(),p=!0,run_all(d.before_update),d.fragment=n?n(d.ctx):!1,e.target){if(e.hydrate){const b=children(e.target);d.fragment&&d.fragment.l(b),b.forEach(detach)}else d.fragment&&d.fragment.c();e.intro&&transition_in(t.$$.fragment),mount_component(t,e.target,e.anchor,e.customElement),flush$1()}set_current_component(h)}class SvelteComponent{$destroy(){destroy_component(this,1),this.$destroy=noop$2}$on(e,r){const n=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return n.push(r),()=>{const o=n.indexOf(r);o!==-1&&n.splice(o,1)}}$set(e){this.$$set&&!is_empty(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}function getIterator(t){if(typeof t.next=="function")return t;if(typeof t[Symbol.iterator]=="function")return t[Symbol.iterator]();if(typeof t[Symbol.asyncIterator]=="function")return t[Symbol.asyncIterator]();throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')}function defer(){let t,e;return{promise:new Promise((n,o)=>{e=n,t=o}),reject:t,resolve:e}}function _transform(t,e,r){const n=getIterator(r),o=[],s=[];let u=!1,l=!1,h=0,d=null;function p(){for(;s.length>0&&o.length>0;){const{resolve:g}=s.shift(),B=o.shift();g({done:!1,value:B})}for(;s.length>0&&h===0&&u;){const{resolve:g,reject:B}=s.shift();d?(B(d),d=null):g({done:!0,value:void 0})}}async function b(){if(u){p();return}if(!l&&!(h+o.length>=t)){l=!0,h++;try{const{done:g,value:B}=await n.next();g?(u=!0,h--,p()):_(B)}catch(g){u=!0,h--,d=g,p()}l=!1,b()}}async function _(g){try{const B=await e(g);o.push(B)}catch(B){u=!0,d=B}h--,p(),b()}async function T(){if(o.length===0){const B=defer();return s.push(B),b(),B.promise}const g=o.shift();return b(),{done:!1,value:g}}const C={next:T,[Symbol.asyncIterator]:()=>C};return C}function transform(t,e,r){return e===void 0?(n,o)=>o?transform(t,n,o):transform(t,n):r===void 0?n=>transform(t,e,n):_transform(t,e,r)}var commonjsGlobal=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function getAugmentedNamespace(t){if(t.__esModule)return t;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(t).forEach(function(r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}),e}var pRetry$2={exports:{}},retry$2={};function RetryOperation(t,e){typeof e=="boolean"&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var retry_operation=RetryOperation;RetryOperation.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)};RetryOperation.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null};RetryOperation.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=new Date().getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.push(t),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var n=this;return this._timer=setTimeout(function(){n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout(function(){n._operationTimeoutCb(n._attempts)},n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)},r),this._options.unref&&this._timer.unref(),!0};RetryOperation.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)};RetryOperation.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)};RetryOperation.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)};RetryOperation.prototype.start=RetryOperation.prototype.try;RetryOperation.prototype.errors=function(){return this._errors};RetryOperation.prototype.attempts=function(){return this._attempts};RetryOperation.prototype.mainError=function(){if(this._errors.length===0)return null;for(var t={},e=null,r=0,n=0;n<this._errors.length;n++){var o=this._errors[n],s=o.message,u=(t[s]||0)+1;t[s]=u,u>=r&&(e=o,r=u)}return e};(function(t){var e=retry_operation;t.operation=function(r){var n=t.timeouts(r);return new e(n,{forever:r&&(r.forever||r.retries===1/0),unref:r&&r.unref,maxRetryTime:r&&r.maxRetryTime})},t.timeouts=function(r){if(r instanceof Array)return[].concat(r);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var o in r)n[o]=r[o];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var s=[],u=0;u<n.retries;u++)s.push(this.createTimeout(u,n));return r&&r.forever&&!s.length&&s.push(this.createTimeout(u,n)),s.sort(function(l,h){return l-h}),s},t.createTimeout=function(r,n){var o=n.randomize?Math.random()+1:1,s=Math.round(o*Math.max(n.minTimeout,1)*Math.pow(n.factor,r));return s=Math.min(s,n.maxTimeout),s},t.wrap=function(r,n,o){if(n instanceof Array&&(o=n,n=null),!o){o=[];for(var s in r)typeof r[s]=="function"&&o.push(s)}for(var u=0;u<o.length;u++){var l=o[u],h=r[l];r[l]=function(p){var b=t.operation(n),_=Array.prototype.slice.call(arguments,1),T=_.pop();_.push(function(C){b.retry(C)||(C&&(arguments[0]=b.mainError()),T.apply(this,arguments))}),b.attempt(function(){p.apply(r,_)})}.bind(r,h),r[l].options=n}}})(retry$2);var retry$1=retry$2;const retry=retry$1,networkErrorMsgs=["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed"];class AbortError extends Error{constructor(e){super();e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const decorateErrorWithCounts=(t,e,r)=>{const n=r.retries-(e-1);return t.attemptNumber=e,t.retriesLeft=n,t},isNetworkError=t=>networkErrorMsgs.includes(t),pRetry=(t,e)=>new Promise((r,n)=>{e=M({onFailedAttempt:()=>{},retries:10},e);const o=retry.operation(e);o.attempt(async s=>{try{r(await t(s))}catch(u){if(!(u instanceof Error)){n(new TypeError(`Non-error was thrown: "${u}". You should only throw errors.`));return}if(u instanceof AbortError)o.stop(),n(u.originalError);else if(u instanceof TypeError&&!isNetworkError(u.message))o.stop(),n(u);else{decorateErrorWithCounts(u,s,e);try{await e.onFailedAttempt(u)}catch(l){n(l);return}o.retry(u)||n(o.mainError())}}})});pRetry$2.exports=pRetry;pRetry$2.exports.default=pRetry;pRetry$2.exports.AbortError=AbortError;var pRetry$1=pRetry$2.exports;const last=async t=>{let e;for await(const r of t)e=r;return e};var itLast=last,itPipe={exports:{}};const rawPipe=(...t)=>{let e;for(;t.length;)e=t.shift()(e);return e},isIterable$1=t=>t&&(typeof t[Symbol.asyncIterator]=="function"||typeof t[Symbol.iterator]=="function"||typeof t.next=="function"),isDuplex=t=>t&&typeof t.sink=="function"&&isIterable$1(t.source),duplexPipelineFn=t=>e=>(t.sink(e),t.source),pipe=(...t)=>{if(isDuplex(t[0])){const e=t[0];t[0]=()=>e.source}else if(isIterable$1(t[0])){const e=t[0];t[0]=()=>e}if(t.length>1&&isDuplex(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let e=1;e<t.length-1;e++)isDuplex(t[e])&&(t[e]=duplexPipelineFn(t[e]));return rawPipe(...t)};itPipe.exports=pipe;itPipe.exports.pipe=pipe;itPipe.exports.rawPipe=rawPipe;itPipe.exports.isIterable=isIterable$1;itPipe.exports.isDuplex=isDuplex;var pipe$1=itPipe.exports,encode_1$1=encode$7,MSB$3=128,REST$3=127,MSBALL$1=~REST$3,INT$1=Math.pow(2,31);function encode$7(t,e,r){if(Number.MAX_SAFE_INTEGER&&t>Number.MAX_SAFE_INTEGER)throw encode$7.bytes=0,new RangeError("Could not encode varint");e=e||[],r=r||0;for(var n=r;t>=INT$1;)e[r++]=t&255|MSB$3,t/=128;for(;t&MSBALL$1;)e[r++]=t&255|MSB$3,t>>>=7;return e[r]=t|0,encode$7.bytes=r-n+1,e}var decode$9=read$1,MSB$2=128,REST$2=127;function read$1(t,e){var r=0,e=e||0,n=0,o=e,s,u=t.length;do{if(o>=u||n>49)throw read$1.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=n<28?(s&REST$2)<<n:(s&REST$2)*Math.pow(2,n),n+=7}while(s>=MSB$2);return read$1.bytes=o-e,r}var N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),length$1=function(t){return t<N1$1?1:t<N2$1?2:t<N3$1?3:t<N4$1?4:t<N5$1?5:t<N6$1?6:t<N7$1?7:t<N8$1?8:t<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$9,encodingLength:length$1},encode_1=encode$6,MSB=128,REST=127,MSBALL=~REST,INT=Math.pow(2,31);function encode$6(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT;)e[r++]=t&255|MSB,t/=128;for(;t&MSBALL;)e[r++]=t&255|MSB,t>>>=7;return e[r]=t|0,encode$6.bytes=r-n+1,e}var decode$8=read,MSB$1=128,REST$1=127;function read(t,e){var r=0,e=e||0,n=0,o=e,s,u=t.length;do{if(o>=u)throw read.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=n<28?(s&REST$1)<<n:(s&REST$1)*Math.pow(2,n),n+=7}while(s>=MSB$1);return read.bytes=o-e,r}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(t){return t<N1?1:t<N2?2:t<N3?3:t<N4?4:t<N5?5:t<N6?6:t<N7?7:t<N8?8:t<N9?9:10},varint={encode:encode_1,decode:decode$8,encodingLength:length},_brrp_varint=varint;const decode$7=t=>[_brrp_varint.decode(t),_brrp_varint.decode.bytes],encodeTo=(t,e,r=0)=>(_brrp_varint.encode(t,e,r),e),encodingLength=t=>_brrp_varint.encodingLength(t),empty=new Uint8Array(0),fromHex=t=>{const e=t.match(/../g);return e?new Uint8Array(e.map(r=>parseInt(r,16))):empty},equals$2=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$3=t=>new TextEncoder().encode(t),toString$1=t=>new TextDecoder().decode(t),create$4=(t,e)=>{const r=e.byteLength,n=encodingLength(t),o=n+encodingLength(r),s=new Uint8Array(o+r);return encodeTo(t,s,0),encodeTo(r,s,n),s.set(e,o),new Digest$1(t,r,e,s)},decode$6=t=>{const e=coerce(t),[r,n]=decode$7(e),[o,s]=decode$7(e.subarray(n)),u=e.subarray(n+s);if(u.byteLength!==o)throw new Error("Incorrect length");return new Digest$1(r,o,u,e)},equals$1=(t,e)=>t===e?!0:t.code===e.code&&t.size===e.size&&equals$2(t.bytes,e.bytes);class Digest$1{constructor(e,r,n,o){this.code=e,this.size=r,this.digest=n,this.bytes=o}}var digest=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",create:create$4,decode:decode$6,equals:equals$1,Digest:Digest$1});function base(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var o=0;o<t.length;o++){var s=t.charAt(o),u=s.charCodeAt(0);if(r[u]!==255)throw new TypeError(s+" is ambiguous");r[u]=o}var l=t.length,h=t.charAt(0),d=Math.log(l)/Math.log(256),p=Math.log(256)/Math.log(l);function b(C){if(C instanceof Uint8Array||(ArrayBuffer.isView(C)?C=new Uint8Array(C.buffer,C.byteOffset,C.byteLength):Array.isArray(C)&&(C=Uint8Array.from(C))),!(C instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(C.length===0)return"";for(var g=0,B=0,k=0,R=C.length;k!==R&&C[k]===0;)k++,g++;for(var x=(R-k)*p+1>>>0,v=new Uint8Array(x);k!==R;){for(var E=C[k],A=0,S=x-1;(E!==0||A<B)&&S!==-1;S--,A++)E+=256*v[S]>>>0,v[S]=E%l>>>0,E=E/l>>>0;if(E!==0)throw new Error("Non-zero carry");B=A,k++}for(var D=x-B;D!==x&&v[D]===0;)D++;for(var I=h.repeat(g);D<x;++D)I+=t.charAt(v[D]);return I}function _(C){if(typeof C!="string")throw new TypeError("Expected String");if(C.length===0)return new Uint8Array;var g=0;if(C[g]!==" "){for(var B=0,k=0;C[g]===h;)B++,g++;for(var R=(C.length-g)*d+1>>>0,x=new Uint8Array(R);C[g];){var v=r[C.charCodeAt(g)];if(v===255)return;for(var E=0,A=R-1;(v!==0||E<k)&&A!==-1;A--,E++)v+=l*x[A]>>>0,x[A]=v%256>>>0,v=v/256>>>0;if(v!==0)throw new Error("Non-zero carry");k=E,g++}if(C[g]!==" "){for(var S=R-k;S!==R&&x[S]===0;)S++;for(var D=new Uint8Array(B+(R-S)),I=B;S!==R;)D[I++]=x[S++];return D}}}function T(C){var g=_(C);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:b,decodeUnsafe:_,decode:T}}var src$4=base,_brrp__multiformats_scope_baseX=src$4;class Encoder{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,r,n){this.name=e,this.prefix=r,this.baseDecode=n}decode(e){if(typeof e=="string")switch(e[0]){case this.prefix:return this.baseDecode(e.slice(1));default:throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)}else throw Error("Can only multibase decode strings")}or(e){return or(this,e)}}class ComposedDecoder{constructor(e){this.decoders=e}or(e){return or(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(t,e)=>new ComposedDecoder(M(M({},t.decoders||{[t.prefix]:t}),e.decoders||{[e.prefix]:e}));class Codec{constructor(e,r,n,o){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=o,this.encoder=new Encoder(e,r,n),this.decoder=new Decoder(e,r,o)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$1=({name:t,prefix:e,encode:r,decode:n})=>new Codec(t,e,r,n),baseX=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:o}=_brrp__multiformats_scope_baseX(r,e);return from$1({prefix:t,name:e,encode:n,decode:s=>coerce(o(s))})},decode$5=(t,e,r,n)=>{const o={};for(let p=0;p<e.length;++p)o[e[p]]=p;let s=t.length;for(;t[s-1]==="=";)--s;const u=new Uint8Array(s*r/8|0);let l=0,h=0,d=0;for(let p=0;p<s;++p){const b=o[t[p]];if(b===void 0)throw new SyntaxError(`Non-${n} character`);h=h<<r|b,l+=r,l>=8&&(l-=8,u[d++]=255&h>>l)}if(l>=r||255&h<<8-l)throw new SyntaxError("Unexpected end of data");return u},encode$5=(t,e,r)=>{const n=e[e.length-1]==="=",o=(1<<r)-1;let s="",u=0,l=0;for(let h=0;h<t.length;++h)for(l=l<<8|t[h],u+=8;u>r;)u-=r,s+=e[o&l>>u];if(u&&(s+=e[o&l<<r-u]),n)for(;s.length*r&7;)s+="=";return s},rfc4648=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$1({prefix:e,name:t,encode(o){return encode$5(o,n,r)},decode(o){return decode$5(o,n,r,t)}}),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var base58=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base58btc,base58flickr});const base32$1=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var base32$2=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base32:base32$1,base32upper,base32pad,base32padupper,base32hex,base32hexupper,base32hexpad,base32hexpadupper,base32z});class CID$1{constructor(e,r,n,o){this.code=r,this.version=e,this.multihash=n,this.bytes=o,this.byteOffset=o.byteOffset,this.byteLength=o.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly$1,version:readonly$1,multihash:readonly$1,bytes:readonly$1,_baseCache:hidden,asCID:hidden})}toV0(){switch(this.version){case 0:return this;default:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID$1.createV0(r)}}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$4(e,r);return CID$1.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&equals$1(this.multihash,e.multihash)}toString(e){const{bytes:r,version:n,_baseCache:o}=this;switch(n){case 0:return toStringV0(r,o,e||base58btc.encoder);default:return toStringV1(r,o,e||base32$1.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return deprecate(/^0\.0/,IS_CID_DEPRECATION),!!(e&&(e[cidSymbol]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof CID$1)return e;if(e!=null&&e.asCID===e){const{version:r,code:n,multihash:o,bytes:s}=e;return new CID$1(r,n,o,s||encodeCID(r,n,o.bytes))}else if(e!=null&&e[cidSymbol]===!0){const{version:r,multihash:n,code:o}=e,s=decode$6(n);return CID$1.create(r,o,s)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(r!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID$1(e,r,n,n.bytes)}case 1:{const o=encodeCID(e,r,n.bytes);return new CID$1(e,r,n,o)}default:throw new Error("Invalid version")}}static createV0(e){return CID$1.create(0,DAG_PB_CODE,e)}static createV1(e,r){return CID$1.create(1,e,r)}static decode(e){const[r,n]=CID$1.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID$1.inspectBytes(e),n=r.size-r.multihashSize,o=coerce(e.subarray(n,n+r.multihashSize));if(o.byteLength!==r.multihashSize)throw new Error("Incorrect length");const s=o.subarray(r.multihashSize-r.digestSize),u=new Digest$1(r.multihashCode,r.digestSize,s,o);return[r.version===0?CID$1.createV0(u):CID$1.createV1(r.codec,u),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[b,_]=decode$7(e.subarray(r));return r+=_,b};let o=n(),s=DAG_PB_CODE;if(o===18?(o=0,r=0):o===1&&(s=n()),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const u=r,l=n(),h=n(),d=r+h,p=d-u;return{version:o,codec:s,multihashCode:l,digestSize:h,multihashSize:p,size:d}}static parse(e,r){const[n,o]=parseCIDtoBytes(e,r),s=CID$1.decode(o);return s._baseCache.set(n,e),s}}const parseCIDtoBytes=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc;return[base58btc.prefix,r.decode(`${base58btc.prefix}${t}`)]}case base58btc.prefix:{const r=e||base58btc;return[base58btc.prefix,r.decode(t)]}case base32$1.prefix:{const r=e||base32$1;return[base32$1.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const o=e.get(n);if(o==null){const s=r.encode(t).slice(1);return e.set(n,s),s}else return o},toStringV1=(t,e,r)=>{const{prefix:n}=r,o=e.get(n);if(o==null){const s=r.encode(t);return e.set(n,s),s}else return o},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(t,e,r)=>{const n=encodingLength(t),o=n+encodingLength(e),s=new Uint8Array(o+r.byteLength);return encodeTo(t,s,0),encodeTo(e,s,n),s.set(r,o),s},cidSymbol=Symbol.for("@ipld/js-cid/CID"),readonly$1={writable:!1,configurable:!1,enumerable:!0},hidden={writable:!1,enumerable:!1,configurable:!1},version="0.0.0-dev",deprecate=(t,e)=>{if(t.test(version))console.warn(e);else throw new Error(e)},IS_CID_DEPRECATION=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;var cid=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",CID:CID$1});const typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(t){if(t===null)return"null";if(t===void 0)return"undefined";if(t===!0||t===!1)return"boolean";const e=typeof t;if(typeofs.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(t))return"Array";if(isBuffer$1(t))return"Buffer";const r=getObjectType(t);return r||"Object"}function isBuffer$1(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function getObjectType(t){const e=Object.prototype.toString.call(t).slice(8,-1);if(objectTypeNames.includes(e))return e}class Type{constructor(e,r,n){this.major=e,this.majorEncoded=e<<5,this.name=r,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0);Type.negint=new Type(1,"negint",!0);Type.bytes=new Type(2,"bytes",!0);Type.string=new Type(3,"string",!0);Type.array=new Type(4,"array",!1);Type.map=new Type(5,"map",!1);Type.tag=new Type(6,"tag",!1);Type.float=new Type(7,"float",!0);Type.false=new Type(7,"false",!0);Type.true=new Type(7,"true",!0);Type.null=new Type(7,"null",!0);Type.undefined=new Type(7,"undefined",!0);Type.break=new Type(7,"break",!0);class Token{constructor(e,r,n){this.type=e,this.value=r,this.encodedLength=n,this.encodedBytes=void 0}toString(){return`Token[${this.type}].${this.value}`}}const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",textDecoder$1=new TextDecoder,textEncoder$2=new TextEncoder;function isBuffer(t){return useBuffer&&globalThis.Buffer.isBuffer(t)}function asU8A(t){return t instanceof Uint8Array?isBuffer(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}const toString=useBuffer?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):utf8Slice(t,e,r):(t,e,r)=>r-e>64?textDecoder$1.decode(t.subarray(e,r)):utf8Slice(t,e,r),fromString$2=useBuffer?t=>t.length>64?globalThis.Buffer.from(t):utf8ToBytes(t):t=>t.length>64?textEncoder$2.encode(t):utf8ToBytes(t),fromArray=t=>Uint8Array.from(t),slice=useBuffer?(t,e,r)=>isBuffer(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),concat$2=useBuffer?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),asU8A(globalThis.Buffer.concat(t,e))):(t,e)=>{const r=new Uint8Array(e);let n=0;for(let o of t)n+o.length>r.length&&(o=o.subarray(0,r.length-n)),r.set(o,n),n+=o.length;return r},alloc=useBuffer?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function compare(t,e){if(isBuffer(t)&&isBuffer(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function utf8ToBytes(t,e=1/0){let r;const n=t.length;let o=null;const s=[];for(let u=0;u<n;++u){if(r=t.charCodeAt(u),r>55295&&r<57344){if(!o){if(r>56319){(e-=3)>-1&&s.push(239,191,189);continue}else if(u+1===n){(e-=3)>-1&&s.push(239,191,189);continue}o=r;continue}if(r<56320){(e-=3)>-1&&s.push(239,191,189),o=r;continue}r=(o-55296<<10|r-56320)+65536}else o&&(e-=3)>-1&&s.push(239,191,189);if(o=null,r<128){if((e-=1)<0)break;s.push(r)}else if(r<2048){if((e-=2)<0)break;s.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;s.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;s.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return s}function utf8Slice(t,e,r){const n=[];for(;e<r;){const o=t[e];let s=null,u=o>239?4:o>223?3:o>191?2:1;if(e+u<=r){let l,h,d,p;switch(u){case 1:o<128&&(s=o);break;case 2:l=t[e+1],(l&192)==128&&(p=(o&31)<<6|l&63,p>127&&(s=p));break;case 3:l=t[e+1],h=t[e+2],(l&192)==128&&(h&192)==128&&(p=(o&15)<<12|(l&63)<<6|h&63,p>2047&&(p<55296||p>57343)&&(s=p));break;case 4:l=t[e+1],h=t[e+2],d=t[e+3],(l&192)==128&&(h&192)==128&&(d&192)==128&&(p=(o&15)<<18|(l&63)<<12|(h&63)<<6|d&63,p>65535&&p<1114112&&(s=p))}}s===null?(s=65533,u=1):s>65535&&(s-=65536,n.push(s>>>10&1023|55296),s=56320|s&1023),n.push(s),e+=u}return decodeCodePointsArray(n)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(t){const e=t.length;if(e<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=MAX_ARGUMENTS_LENGTH));return r}const defaultChunkSize=256;class Bl{constructor(e=defaultChunkSize){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.chunks=[],this.cursor=0,this.maxCursor=-1,this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let r=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const o=r.length-(this.maxCursor-this.cursor)-1;r.set(e,o)}else{if(r){const o=r.length-(this.maxCursor-this.cursor)-1;o<r.length&&(this.chunks[this.chunks.length-1]=r.subarray(0,o),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(r=alloc(this.chunkSize),this.chunks.push(r),this.maxCursor+=r.length,this._initReuseChunk===null&&(this._initReuseChunk=r),r.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let r;if(this.chunks.length===1){const n=this.chunks[0];e&&this.cursor>n.length/2?(r=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):r=slice(n,0,this.cursor)}else r=concat$2(this.chunks,this.cursor);return e&&this.reset(),r}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(t,e,r){if(t.length-e<r)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(t,e,r){assertEnoughData(t,e,1);const n=t[e];if(r.strict===!0&&n<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint16(t,e,r){assertEnoughData(t,e,2);const n=t[e]<<8|t[e+1];if(r.strict===!0&&n<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint32(t,e,r){assertEnoughData(t,e,4);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint64(t,e,r){assertEnoughData(t,e,8);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],o=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],s=(BigInt(n)<<BigInt(32))+BigInt(o);if(r.strict===!0&&s<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(s<=Number.MAX_SAFE_INTEGER)return Number(s);if(r.allowBigInt===!0)return s;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(t,e,r,n){return new Token(Type.uint,readUint8(t,e+1,n),2)}function decodeUint16(t,e,r,n){return new Token(Type.uint,readUint16(t,e+1,n),3)}function decodeUint32(t,e,r,n){return new Token(Type.uint,readUint32(t,e+1,n),5)}function decodeUint64(t,e,r,n){return new Token(Type.uint,readUint64(t,e+1,n),9)}function encodeUint(t,e){return encodeUintValue(t,0,e.value)}function encodeUintValue(t,e,r){if(r<uintBoundaries[0]){const n=Number(r);t.push([e|n])}else if(r<uintBoundaries[1]){const n=Number(r);t.push([e|24,n])}else if(r<uintBoundaries[2]){const n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<uintBoundaries[3]){const n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(r);if(n<uintBoundaries[4]){const o=[e|27,0,0,0,0,0,0,0];let s=Number(n&BigInt(4294967295)),u=Number(n>>BigInt(32)&BigInt(4294967295));o[8]=s&255,s=s>>8,o[7]=s&255,s=s>>8,o[6]=s&255,s=s>>8,o[5]=s&255,o[4]=u&255,u=u>>8,o[3]=u&255,u=u>>8,o[2]=u&255,u=u>>8,o[1]=u&255,t.push(o)}else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)}}encodeUint.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};encodeUintValue.encodedSize=function(e){return e<uintBoundaries[0]?1:e<uintBoundaries[1]?2:e<uintBoundaries[2]?3:e<uintBoundaries[3]?5:9};encodeUint.compareTokens=function(e,r){return e.value<r.value?-1:e.value>r.value?1:0};function decodeNegint8(t,e,r,n){return new Token(Type.negint,-1-readUint8(t,e+1,n),2)}function decodeNegint16(t,e,r,n){return new Token(Type.negint,-1-readUint16(t,e+1,n),3)}function decodeNegint32(t,e,r,n){return new Token(Type.negint,-1-readUint32(t,e+1,n),5)}const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o!="bigint"){const s=-1-o;if(s>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,s,9)}if(n.allowBigInt!==!0)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(o),9)}function encodeNegint(t,e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;encodeUintValue(t,e.type.majorEncoded,n)}encodeNegint.encodedSize=function(e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;return n<uintBoundaries[0]?1:n<uintBoundaries[1]?2:n<uintBoundaries[2]?3:n<uintBoundaries[3]?5:9};encodeNegint.compareTokens=function(e,r){return e.value<r.value?1:e.value>r.value?-1:0};function toToken$3(t,e,r,n){assertEnoughData(t,e,r+n);const o=slice(t,e+r,e+r+n);return new Token(Type.bytes,o,r+n)}function decodeBytesCompact(t,e,r,n){return toToken$3(t,e,1,r)}function decodeBytes8(t,e,r,n){return toToken$3(t,e,2,readUint8(t,e+1,n))}function decodeBytes16(t,e,r,n){return toToken$3(t,e,3,readUint16(t,e+1,n))}function decodeBytes32(t,e,r,n){return toToken$3(t,e,5,readUint32(t,e+1,n))}function decodeBytes64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(t,e,9,o)}function tokenBytes(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===Type.string?fromString$2(t.value):t.value),t.encodedBytes}function encodeBytes(t,e){const r=tokenBytes(e);encodeUintValue(t,e.type.majorEncoded,r.length),t.push(r)}encodeBytes.encodedSize=function(e){const r=tokenBytes(e);return encodeUintValue.encodedSize(r.length)+r.length};encodeBytes.compareTokens=function(e,r){return compareBytes(tokenBytes(e),tokenBytes(r))};function compareBytes(t,e){return t.length<e.length?-1:t.length>e.length?1:compare(t,e)}function toToken$2(t,e,r,n){const o=r+n;return assertEnoughData(t,e,o),new Token(Type.string,toString(t,e+r,e+o),o)}function decodeStringCompact(t,e,r,n){return toToken$2(t,e,1,r)}function decodeString8(t,e,r,n){return toToken$2(t,e,2,readUint8(t,e+1,n))}function decodeString16(t,e,r,n){return toToken$2(t,e,3,readUint16(t,e+1,n))}function decodeString32(t,e,r,n){return toToken$2(t,e,5,readUint32(t,e+1,n))}function decodeString64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(t,e,9,o)}const encodeString=encodeBytes;function toToken$1(t,e,r,n){return new Token(Type.array,n,r)}function decodeArrayCompact(t,e,r,n){return toToken$1(t,e,1,r)}function decodeArray8(t,e,r,n){return toToken$1(t,e,2,readUint8(t,e+1,n))}function decodeArray16(t,e,r,n){return toToken$1(t,e,3,readUint16(t,e+1,n))}function decodeArray32(t,e,r,n){return toToken$1(t,e,5,readUint32(t,e+1,n))}function decodeArray64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(t,e,9,o)}function decodeArrayIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(t,e,1,1/0)}function encodeArray(t,e){encodeUintValue(t,Type.array.majorEncoded,e.value)}encodeArray.compareTokens=encodeUint.compareTokens;function toToken(t,e,r,n){return new Token(Type.map,n,r)}function decodeMapCompact(t,e,r,n){return toToken(t,e,1,r)}function decodeMap8(t,e,r,n){return toToken(t,e,2,readUint8(t,e+1,n))}function decodeMap16(t,e,r,n){return toToken(t,e,3,readUint16(t,e+1,n))}function decodeMap32(t,e,r,n){return toToken(t,e,5,readUint32(t,e+1,n))}function decodeMap64(t,e,r,n){const o=readUint64(t,e+1,n);if(typeof o=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(t,e,9,o)}function decodeMapIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(t,e,1,1/0)}function encodeMap(t,e){encodeUintValue(t,Type.map.majorEncoded,e.value)}encodeMap.compareTokens=encodeUint.compareTokens;function decodeTagCompact(t,e,r,n){return new Token(Type.tag,r,1)}function decodeTag8(t,e,r,n){return new Token(Type.tag,readUint8(t,e+1,n),2)}function decodeTag16(t,e,r,n){return new Token(Type.tag,readUint16(t,e+1,n),3)}function decodeTag32(t,e,r,n){return new Token(Type.tag,readUint32(t,e+1,n),5)}function decodeTag64(t,e,r,n){return new Token(Type.tag,readUint64(t,e+1,n),9)}function encodeTag(t,e){encodeUintValue(t,Type.tag.majorEncoded,e.value)}encodeTag.compareTokens=encodeUint.compareTokens;const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,t,e)}function decodeFloat16(t,e,r,n){return createToken(readFloat16(t,e+1),3,n)}function decodeFloat32(t,e,r,n){return createToken(readFloat32(t,e+1),5,n)}function decodeFloat64(t,e,r,n){return createToken(readFloat64(t,e+1),9,n)}function encodeFloat(t,e,r){const n=e.value;if(n===!1)t.push([Type.float.majorEncoded|MINOR_FALSE]);else if(n===!0)t.push([Type.float.majorEncoded|MINOR_TRUE]);else if(n===null)t.push([Type.float.majorEncoded|MINOR_NULL]);else if(n===void 0)t.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let o,s=!1;(!r||r.float64!==!0)&&(encodeFloat16(n),o=readFloat16(ui8a,1),n===o||Number.isNaN(n)?(ui8a[0]=249,t.push(ui8a.slice(0,3)),s=!0):(encodeFloat32(n),o=readFloat32(ui8a,1),n===o&&(ui8a[0]=250,t.push(ui8a.slice(0,5)),s=!0))),s||(encodeFloat64(n),o=readFloat64(ui8a,1),ui8a[0]=251,t.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(e,r){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;let o;if(!r||r.float64!==!0){if(encodeFloat16(n),o=readFloat16(ui8a,1),n===o||Number.isNaN(n))return 3;if(encodeFloat32(n),o=readFloat32(ui8a,1),n===o)return 5}return 9};const buffer$1=new ArrayBuffer(9),dataView=new DataView(buffer$1,1),ui8a=new Uint8Array(buffer$1,0);function encodeFloat16(t){if(t===1/0)dataView.setUint16(0,31744,!1);else if(t===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(t))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,t);const e=dataView.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)dataView.setUint16(0,31744,!1);else if(r===0)dataView.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{const o=r-127;o<-24?dataView.setUint16(0,0):o<-14?dataView.setUint16(0,(e&2147483648)>>16|1<<24+o,!1):dataView.setUint16(0,(e&2147483648)>>16|o+15<<10|n>>13,!1)}}}function readFloat16(t,e){if(t.length-e<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;const n=r>>10&31,o=r&1023;let s;return n===0?s=o*2**-24:n!==31?s=(o+1024)*2**(n-25):s=o===0?1/0:NaN,r&32768?-s:s}function encodeFloat32(t){dataView.setFloat32(0,t,!1)}function readFloat32(t,e){if(t.length-e<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function encodeFloat64(t){dataView.setFloat64(0,t,!1)}function readFloat64(t,e){if(t.length-e<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}encodeFloat.compareTokens=encodeUint.compareTokens;function invalidMinor(t,e,r){throw new Error(`${decodeErrPrefix} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function errorer(t){return()=>{throw new Error(`${decodeErrPrefix} ${t}`)}}const jump=[];for(let t=0;t<=23;t++)jump[t]=invalidMinor;jump[24]=decodeUint8;jump[25]=decodeUint16;jump[26]=decodeUint32;jump[27]=decodeUint64;jump[28]=invalidMinor;jump[29]=invalidMinor;jump[30]=invalidMinor;jump[31]=invalidMinor;for(let t=32;t<=55;t++)jump[t]=invalidMinor;jump[56]=decodeNegint8;jump[57]=decodeNegint16;jump[58]=decodeNegint32;jump[59]=decodeNegint64;jump[60]=invalidMinor;jump[61]=invalidMinor;jump[62]=invalidMinor;jump[63]=invalidMinor;for(let t=64;t<=87;t++)jump[t]=decodeBytesCompact;jump[88]=decodeBytes8;jump[89]=decodeBytes16;jump[90]=decodeBytes32;jump[91]=decodeBytes64;jump[92]=invalidMinor;jump[93]=invalidMinor;jump[94]=invalidMinor;jump[95]=errorer("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)jump[t]=decodeStringCompact;jump[120]=decodeString8;jump[121]=decodeString16;jump[122]=decodeString32;jump[123]=decodeString64;jump[124]=invalidMinor;jump[125]=invalidMinor;jump[126]=invalidMinor;jump[127]=errorer("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)jump[t]=decodeArrayCompact;jump[152]=decodeArray8;jump[153]=decodeArray16;jump[154]=decodeArray32;jump[155]=decodeArray64;jump[156]=invalidMinor;jump[157]=invalidMinor;jump[158]=invalidMinor;jump[159]=decodeArrayIndefinite;for(let t=160;t<=183;t++)jump[t]=decodeMapCompact;jump[184]=decodeMap8;jump[185]=decodeMap16;jump[186]=decodeMap32;jump[187]=decodeMap64;jump[188]=invalidMinor;jump[189]=invalidMinor;jump[190]=invalidMinor;jump[191]=decodeMapIndefinite;for(let t=192;t<=215;t++)jump[t]=decodeTagCompact;jump[216]=decodeTag8;jump[217]=decodeTag16;jump[218]=decodeTag32;jump[219]=decodeTag64;jump[220]=invalidMinor;jump[221]=invalidMinor;jump[222]=invalidMinor;jump[223]=invalidMinor;for(let t=224;t<=243;t++)jump[t]=errorer("simple values are not supported");jump[244]=invalidMinor;jump[245]=invalidMinor;jump[246]=invalidMinor;jump[247]=decodeUndefined;jump[248]=errorer("simple values are not supported");jump[249]=decodeFloat16;jump[250]=decodeFloat32;jump[251]=decodeFloat64;jump[252]=invalidMinor;jump[253]=invalidMinor;jump[254]=invalidMinor;jump[255]=decodeBreak;const quick=[];for(let t=0;t<24;t++)quick[t]=new Token(Type.uint,t,1);for(let t=-1;t>=-24;t--)quick[31-t]=new Token(Type.negint,t,1);quick[64]=new Token(Type.bytes,new Uint8Array(0),1);quick[96]=new Token(Type.string,"",1);quick[128]=new Token(Type.array,0,1);quick[160]=new Token(Type.map,0,1);quick[244]=new Token(Type.false,!1,1);quick[245]=new Token(Type.true,!0,1);quick[246]=new Token(Type.null,null,1);function quickEncodeToken(t){switch(t.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return t.value.length?void 0:fromArray([64]);case Type.string:return t.value===""?fromArray([96]):void 0;case Type.array:return t.value===0?fromArray([128]):void 0;case Type.map:return t.value===0?fromArray([160]):void 0;case Type.uint:return t.value<24?fromArray([Number(t.value)]):void 0;case Type.negint:if(t.value>=-24)return fromArray([31-Number(t.value)])}}const defaultEncodeOptions={float64:!1,mapSorter,quickEncodeToken},cborEncoders=[];cborEncoders[Type.uint.major]=encodeUint;cborEncoders[Type.negint.major]=encodeNegint;cborEncoders[Type.bytes.major]=encodeBytes;cborEncoders[Type.string.major]=encodeString;cborEncoders[Type.array.major]=encodeArray;cborEncoders[Type.map.major]=encodeMap;cborEncoders[Type.tag.major]=encodeTag;cborEncoders[Type.float.major]=encodeFloat;const buf=new Bl;class Ref{constructor(e,r){this.obj=e,this.parent=r}includes(e){let r=this;do if(r.obj===e)return!0;while(r=r.parent);return!1}static createCheck(e,r){if(e&&e.includes(r))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(r,e)}}const simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new Token(Type.float,t):t>=0?new Token(Type.uint,t):new Token(Type.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new Token(Type.uint,t):new Token(Type.negint,t)},Uint8Array(t,e,r,n){return new Token(Type.bytes,t)},string(t,e,r,n){return new Token(Type.string,t)},boolean(t,e,r,n){return t?simpleTokens.true:simpleTokens.false},null(t,e,r,n){return simpleTokens.null},undefined(t,e,r,n){return simpleTokens.undefined},ArrayBuffer(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new Token(Type.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;n=Ref.createCheck(n,t);const o=[];let s=0;for(const u of t)o[s++]=objectToTokens(u,r,n);return r.addBreakTokens?[new Token(Type.array,t.length),o,new Token(Type.break)]:[new Token(Type.array,t.length),o]},Object(t,e,r,n){const o=e!=="Object",s=o?t.keys():Object.keys(t),u=o?t.size:s.length;if(!u)return r.addBreakTokens===!0?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;n=Ref.createCheck(n,t);const l=[];let h=0;for(const d of s)l[h++]=[objectToTokens(d,r,n),objectToTokens(o?t.get(d):t[d],r,n)];return sortMapEntries(l,r),r.addBreakTokens?[new Token(Type.map,u),l,new Token(Type.break)]:[new Token(Type.map,u),l]}};typeEncoders.Map=typeEncoders.Object;typeEncoders.Buffer=typeEncoders.Uint8Array;for(const t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${t}Array`]=typeEncoders.DataView;function objectToTokens(t,e={},r){const n=is(t),o=e&&e.typeEncoders&&e.typeEncoders[n]||typeEncoders[n];if(typeof o=="function"){const u=o(t,n,e,r);if(u!=null)return u}const s=typeEncoders[n];if(!s)throw new Error(`${encodeErrPrefix} unsupported type: ${n}`);return s(t,n,e,r)}function sortMapEntries(t,e){e.mapSorter&&t.sort(e.mapSorter)}function mapSorter(t,e){const r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);const o=r.type.major,s=cborEncoders[o].compareTokens(r,n);return s===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),s}function tokensToEncoded(t,e,r,n){if(Array.isArray(e))for(const o of e)tokensToEncoded(t,o,r,n);else r[e.type.major](t,e,n)}function encodeCustom(t,e,r){const n=objectToTokens(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){const o=r.quickEncodeToken(n);if(o)return o;const s=e[n.type.major];if(s.encodedSize){const u=s.encodedSize(n,r),l=new Bl(u);if(s(l,n,r),l.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return asU8A(l.chunks[0])}}return tokensToEncoded(buf,n,e,r),buf.toBytes(!0)}function encode$4(t,e){return e=Object.assign({},defaultEncodeOptions,e),encodeCustom(t,cborEncoders,e)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,r={}){this.pos=0,this.data=e,this.options=r}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let r=quick[e];if(r===void 0){const n=jump[e];if(!n)throw new Error(`${decodeErrPrefix} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const o=e&31;r=n(this.data,this.pos,o,this.options)}return this.pos+=r.encodedLength,r}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(t,e,r){const n=[];for(let o=0;o<t.value;o++){const s=tokensToObject(e,r);if(s===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(s===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${o}, expected ${t.value})`);n[o]=s}return n}function tokenToMap(t,e,r){const n=r.useMaps===!0,o=n?void 0:{},s=n?new Map:void 0;for(let u=0;u<t.value;u++){const l=tokensToObject(e,r);if(l===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(l===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${u} [no key], expected ${t.value})`);if(n!==!0&&typeof l!="string")throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof l})`);const h=tokensToObject(e,r);if(h===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${u} [no value], expected ${t.value})`);n?s.set(l,h):o[l]=h}return n?s:o}function tokensToObject(t,e){if(t.done())return DONE;const r=t.next();if(r.type===Type.break)return BREAK;if(r.type.terminal)return r.value;if(r.type===Type.array)return tokenToArray(r,t,e);if(r.type===Type.map)return tokenToMap(r,t,e);if(r.type===Type.tag){if(e.tags&&typeof e.tags[r.value]=="function"){const n=tokensToObject(t,e);return e.tags[r.value](n)}throw new Error(`${decodeErrPrefix} tag not supported (${r.value})`)}throw new Error("unsupported")}function decode$4(t,e){if(!(t instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);e=Object.assign({},defaultDecodeOptions,e);const r=e.tokenizer||new Tokeniser(t,e),n=tokensToObject(r,e);if(n===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(n===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);if(!r.done())throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return n}const CID_CBOR_TAG$1=42;function cidEncoder$1(t){if(t.asCID!==t)return null;const e=CID$1.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token(Type.tag,CID_CBOR_TAG$1),new Token(Type.bytes,r)]}function undefinedEncoder$1(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions$1={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder$1(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID$1.decode(t.subarray(1))}const decodeOptions$1={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$1.tags[CID_CBOR_TAG$1]=cidDecoder$1;const encode$3=t=>encode$4(t,encodeOptions$1),decode$3=t=>decode$4(t,decodeOptions$1),CIDV0_BYTES={SHA2_256:18,LENGTH:32,DAG_PB:112};async function readVarint(t){const e=await t.upTo(8),r=varint$1.decode(e);return t.seek(varint$1.decode.bytes),r}async function readHeader(t){const e=await readVarint(t);if(e===0)throw new Error("Invalid CAR header (zero length)");const r=await t.exactly(e);t.seek(e);const n=decode$3(r);if(n==null||Array.isArray(n)||typeof n!="object")throw new Error("Invalid CAR header format");if(n.version!==1)throw typeof n.version=="string"?new Error(`Invalid CAR version: "${n.version}"`):new Error(`Invalid CAR version: ${n.version}`);if(!Array.isArray(n.roots))throw new Error("Invalid CAR header format");if(Object.keys(n).filter(o=>o!=="roots"&&o!=="version").length)throw new Error("Invalid CAR header format");return n}async function readMultihash(t){const e=await t.upTo(8);varint$1.decode(e);const r=varint$1.decode.bytes,n=varint$1.decode(e.subarray(varint$1.decode.bytes)),o=varint$1.decode.bytes,s=r+o+n,u=await t.exactly(s);return t.seek(s),u}async function readCid(t){const e=await t.exactly(2);if(e[0]===CIDV0_BYTES.SHA2_256&&e[1]===CIDV0_BYTES.LENGTH){const u=await t.exactly(34);t.seek(34);const l=decode$6(u);return CID$1.create(0,CIDV0_BYTES.DAG_PB,l)}const r=await readVarint(t);if(r!==1)throw new Error(`Unexpected CID version (${r})`);const n=await readVarint(t),o=await readMultihash(t),s=decode$6(o);return CID$1.create(r,n,s)}async function readBlockHead(t){const e=t.pos;let r=await readVarint(t);if(r===0)throw new Error("Invalid CAR section (zero length)");r+=t.pos-e;const n=await readCid(t),o=r-(t.pos-e);return{cid:n,length:r,blockLength:o}}async function readBlock(t){const{cid:e,blockLength:r}=await readBlockHead(t),n=await t.exactly(r);return t.seek(r),{bytes:n,cid:e}}async function readBlockIndex(t){const e=t.pos,{cid:r,length:n,blockLength:o}=await readBlockHead(t),s={cid:r,length:n,blockLength:o,offset:e,blockOffset:t.pos};return t.seek(s.blockLength),s}function createDecoder(t){const e=readHeader(t);return{header:()=>e,async*blocks(){for(await e;(await t.upTo(8)).length>0;)yield await readBlock(t)},async*blocksIndex(){for(await e;(await t.upTo(8)).length>0;)yield await readBlockIndex(t)}}}function bytesReader(t){let e=0;return{async upTo(r){return t.subarray(e,e+Math.min(r,t.length-e))},async exactly(r){if(r>t.length-e)throw new Error("Unexpected end of data");return t.subarray(e,e+r)},seek(r){e+=r},get pos(){return e}}}function chunkReader(t){let e=0,r=0,n=0,o=new Uint8Array(0);const s=async u=>{r=o.length-n;const l=[o.subarray(n)];for(;r<u;){const d=await t();if(d==null)break;r<0?d.length>r&&l.push(d.subarray(-r)):l.push(d),r+=d.length}o=new Uint8Array(l.reduce((d,p)=>d+p.length,0));let h=0;for(const d of l)o.set(d,h),h+=d.length;n=0};return{async upTo(u){return o.length-n<u&&await s(u),o.subarray(n,n+Math.min(o.length-n,u))},async exactly(u){if(o.length-n<u&&await s(u),o.length-n<u)throw new Error("Unexpected end of data");return o.subarray(n,n+u)},seek(u){e+=u,n+=u},get pos(){return e}}}function asyncIterableReader(t){const e=t[Symbol.asyncIterator]();async function r(){const n=await e.next();return n.done?null:n.value}return chunkReader(r)}class CarReader{constructor(e,r,n){this._version=e,this._roots=r,this._blocks=n,this._keys=n.map(o=>o.cid.toString())}get version(){return this._version}async getRoots(){return this._roots}async has(e){return this._keys.indexOf(e.toString())>-1}async get(e){const r=this._keys.indexOf(e.toString());return r>-1?this._blocks[r]:void 0}async*blocks(){for(const e of this._blocks)yield e}async*cids(){for(const e of this._blocks)yield e.cid}static async fromBytes(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return decodeReaderComplete(bytesReader(e))}static async fromIterable(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return decodeReaderComplete(asyncIterableReader(e))}}async function decodeReaderComplete(t){const e=createDecoder(t),{version:r,roots:n}=await e.header(),o=[];for await(const s of e.blocks())o.push(s);return new CarReader(r,n,o)}class CarIteratorBase{constructor(e,r,n){this._version=e,this._roots=r,this._iterable=n,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class CarBlockIterator extends CarIteratorBase{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(e){const{version:r,roots:n,iterator:o}=await fromBytes(e);return new CarBlockIterator(r,n,o)}static async fromIterable(e){const{version:r,roots:n,iterator:o}=await fromIterable(e);return new CarBlockIterator(r,n,o)}}async function fromBytes(t){if(!(t instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return decodeIterator(bytesReader(t))}async function fromIterable(t){if(!t||typeof t[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return decodeIterator(asyncIterableReader(t))}async function decodeIterator(t){const e=createDecoder(t),{version:r,roots:n}=await e.header();return{version:r,roots:n,iterator:e.blocks()}}function createHeader(t){const e=encode$3({version:1,roots:t}),r=varint$1.encode(e.length),n=new Uint8Array(r.length+e.length);return n.set(r,0),n.set(e,r.length),n}function createEncoder(t){return{async setRoots(e){const r=createHeader(e);await t.write(r)},async writeBlock(e){const{cid:r,bytes:n}=e;await t.write(new Uint8Array(varint$1.encode(r.bytes.length+n.length))),await t.write(r.bytes),n.length&&await t.write(n)},async close(){return t.end()}}}function noop$1(){}function create$3(){const t=[];let e=null,r=noop$1,n=!1,o=null,s=noop$1;const u=()=>(e||(e=new Promise(d=>{r=()=>{e=null,r=noop$1,d()}})),e),l={write(d){t.push(d);const p=u();return s(),p},async end(){n=!0;const d=u();return s(),d}},h={async next(){const d=t.shift();return d?(t.length===0&&r(),{done:!1,value:d}):n?(r(),{done:!0,value:void 0}):(o||(o=new Promise(p=>{s=()=>(o=null,s=noop$1,p(h.next()))})),o)}};return{writer:l,iterator:h}}class CarWriter{constructor(e,r){this._encoder=r,this._mutex=r.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array)||!e.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const r=CID$1.asCID(e.cid);if(!r)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then(()=>this._encoder.writeBlock({cid:r,bytes:e.bytes})),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(e){e=toRoots(e);const{encoder:r,iterator:n}=encodeWriter(),o=new CarWriter(e,r),s=new CarWriterOut(n);return{writer:o,out:s}}static createAppender(){const{encoder:e,iterator:r}=encodeWriter();e.setRoots=()=>Promise.resolve();const n=new CarWriter([],e),o=new CarWriterOut(r);return{writer:n,out:o}}static async updateRootsInBytes(e,r){const n=bytesReader(e);await readHeader(n);const o=createHeader(r);if(n.pos!==o.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${n.pos} bytes, new header is ${o.length} bytes)`);return e.set(o,0),e}}class CarWriterOut{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function encodeWriter(){const t=create$3(),{writer:e,iterator:r}=t;return{encoder:createEncoder(e),iterator:r}}function toRoots(t){if(t===void 0)return[];if(!Array.isArray(t)){const r=CID$1.asCID(t);if(!r)throw new TypeError("roots must be a single CID or an array of CIDs");return[r]}const e=[];for(const r of t){const n=CID$1.asCID(r);if(!n)throw new TypeError("roots must be a single CID or an array of CIDs");e.push(n)}return e}async function*batch$1(t,e=1){let r=[];e<1&&(e=1);for await(const n of t)for(r.push(n);r.length>=e;)yield r.slice(0,e),r=r.slice(e);for(;r.length;)yield r.slice(0,e),r=r.slice(e)}var itBatch=batch$1;const batch=itBatch;async function*parallelBatch(t,e=1){for await(const r of batch(t,e)){const n=r.map(o=>o().then(s=>({ok:!0,value:s}),s=>({ok:!1,err:s})));for(let o=0;o<n.length;o++){const s=await n[o];if(s.ok)yield s.value;else throw s.err}}}var itParallelBatch=parallelBatch,isPlainObj=t=>{if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty:hasOwnProperty$1}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(t,e,r)=>Object.defineProperty(t,e,{value:r,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=t=>{const e=[];for(const r in t)hasOwnProperty$1.call(t,r)&&e.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(t);for(const n of r)propertyIsEnumerable.call(t,n)&&e.push(n)}return e};function clone(t){return Array.isArray(t)?cloneArray(t):isOptionObject(t)?cloneOptionObject(t):t}function cloneArray(t){const e=t.slice(0,0);return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}function cloneOptionObject(t){const e=Object.getPrototypeOf(t)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}const mergeKeys=(t,e,r,n)=>(r.forEach(o=>{typeof e[o]=="undefined"&&n.ignoreUndefined||(o in t&&t[o]!==Object.getPrototypeOf(t)?defineProperty(t,o,merge(t[o],e[o],n)):defineProperty(t,o,clone(e[o])))}),t),concatArrays=(t,e,r)=>{let n=t.slice(0,0),o=0;return[t,e].forEach(s=>{const u=[];for(let l=0;l<s.length;l++)!hasOwnProperty$1.call(s,l)||(u.push(String(l)),s===t?defineProperty(n,o++,s[l]):defineProperty(n,o++,clone(s[l])));n=mergeKeys(n,s,getEnumerableOwnPropertyKeys(s).filter(l=>!u.includes(l)),r)}),n};function merge(t,e,r){return r.concatArrays&&Array.isArray(t)&&Array.isArray(e)?concatArrays(t,e,r):!isOptionObject(e)||!isOptionObject(t)?clone(e):mergeKeys(t,e,getEnumerableOwnPropertyKeys(e),r)}var mergeOptions=function(...t){const e=merge(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let r={_:{}};for(const n of t)if(n!==void 0){if(!isOptionObject(n))throw new TypeError("`"+n+"` is not an Option Object");r=merge(r,{_:n},e)}return r._};const from=({name:t,code:e,encode:r})=>new Hasher(t,e,r);class Hasher{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}async digest(e){if(e instanceof Uint8Array){const r=await this.encode(e);return create$4(this.code,r)}else throw Error("Unknown type, must be binary type")}}const sha=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256=from({name:"sha2-256",code:18,encode:sha("SHA-256")}),sha512=from({name:"sha2-512",code:19,encode:sha("SHA-512")});var sha2=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",sha256,sha512}),murmurHash3js={exports:{}};(function(t,e){(function(r,n){var o={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function s(g){if(!Array.isArray(g)&&!ArrayBuffer.isView(g))return!1;for(var B=0;B<g.length;B++)if(!Number.isInteger(g[B])||g[B]<0||g[B]>255)return!1;return!0}function u(g,B){return(g&65535)*B+(((g>>>16)*B&65535)<<16)}function l(g,B){return g<<B|g>>>32-B}function h(g){return g^=g>>>16,g=u(g,2246822507),g^=g>>>13,g=u(g,3266489909),g^=g>>>16,g}function d(g,B){g=[g[0]>>>16,g[0]&65535,g[1]>>>16,g[1]&65535],B=[B[0]>>>16,B[0]&65535,B[1]>>>16,B[1]&65535];var k=[0,0,0,0];return k[3]+=g[3]+B[3],k[2]+=k[3]>>>16,k[3]&=65535,k[2]+=g[2]+B[2],k[1]+=k[2]>>>16,k[2]&=65535,k[1]+=g[1]+B[1],k[0]+=k[1]>>>16,k[1]&=65535,k[0]+=g[0]+B[0],k[0]&=65535,[k[0]<<16|k[1],k[2]<<16|k[3]]}function p(g,B){g=[g[0]>>>16,g[0]&65535,g[1]>>>16,g[1]&65535],B=[B[0]>>>16,B[0]&65535,B[1]>>>16,B[1]&65535];var k=[0,0,0,0];return k[3]+=g[3]*B[3],k[2]+=k[3]>>>16,k[3]&=65535,k[2]+=g[2]*B[3],k[1]+=k[2]>>>16,k[2]&=65535,k[2]+=g[3]*B[2],k[1]+=k[2]>>>16,k[2]&=65535,k[1]+=g[1]*B[3],k[0]+=k[1]>>>16,k[1]&=65535,k[1]+=g[2]*B[2],k[0]+=k[1]>>>16,k[1]&=65535,k[1]+=g[3]*B[1],k[0]+=k[1]>>>16,k[1]&=65535,k[0]+=g[0]*B[3]+g[1]*B[2]+g[2]*B[1]+g[3]*B[0],k[0]&=65535,[k[0]<<16|k[1],k[2]<<16|k[3]]}function b(g,B){return B%=64,B===32?[g[1],g[0]]:B<32?[g[0]<<B|g[1]>>>32-B,g[1]<<B|g[0]>>>32-B]:(B-=32,[g[1]<<B|g[0]>>>32-B,g[0]<<B|g[1]>>>32-B])}function _(g,B){return B%=64,B===0?g:B<32?[g[0]<<B|g[1]>>>32-B,g[1]<<B]:[g[1]<<B-32,0]}function T(g,B){return[g[0]^B[0],g[1]^B[1]]}function C(g){return g=T(g,[0,g[0]>>>1]),g=p(g,[4283543511,3981806797]),g=T(g,[0,g[0]>>>1]),g=p(g,[3301882366,444984403]),g=T(g,[0,g[0]>>>1]),g}o.x86.hash32=function(g,B){if(o.inputValidation&&!s(g))return n;B=B||0;for(var k=g.length%4,R=g.length-k,x=B,v=0,E=3432918353,A=461845907,S=0;S<R;S=S+4)v=g[S]|g[S+1]<<8|g[S+2]<<16|g[S+3]<<24,v=u(v,E),v=l(v,15),v=u(v,A),x^=v,x=l(x,13),x=u(x,5)+3864292196;switch(v=0,k){case 3:v^=g[S+2]<<16;case 2:v^=g[S+1]<<8;case 1:v^=g[S],v=u(v,E),v=l(v,15),v=u(v,A),x^=v}return x^=g.length,x=h(x),x>>>0},o.x86.hash128=function(g,B){if(o.inputValidation&&!s(g))return n;B=B||0;for(var k=g.length%16,R=g.length-k,x=B,v=B,E=B,A=B,S=0,D=0,I=0,F=0,V=597399067,G=2869860233,Y=951274213,W=2716044179,N=0;N<R;N=N+16)S=g[N]|g[N+1]<<8|g[N+2]<<16|g[N+3]<<24,D=g[N+4]|g[N+5]<<8|g[N+6]<<16|g[N+7]<<24,I=g[N+8]|g[N+9]<<8|g[N+10]<<16|g[N+11]<<24,F=g[N+12]|g[N+13]<<8|g[N+14]<<16|g[N+15]<<24,S=u(S,V),S=l(S,15),S=u(S,G),x^=S,x=l(x,19),x+=v,x=u(x,5)+1444728091,D=u(D,G),D=l(D,16),D=u(D,Y),v^=D,v=l(v,17),v+=E,v=u(v,5)+197830471,I=u(I,Y),I=l(I,17),I=u(I,W),E^=I,E=l(E,15),E+=A,E=u(E,5)+2530024501,F=u(F,W),F=l(F,18),F=u(F,V),A^=F,A=l(A,13),A+=x,A=u(A,5)+850148119;switch(S=0,D=0,I=0,F=0,k){case 15:F^=g[N+14]<<16;case 14:F^=g[N+13]<<8;case 13:F^=g[N+12],F=u(F,W),F=l(F,18),F=u(F,V),A^=F;case 12:I^=g[N+11]<<24;case 11:I^=g[N+10]<<16;case 10:I^=g[N+9]<<8;case 9:I^=g[N+8],I=u(I,Y),I=l(I,17),I=u(I,W),E^=I;case 8:D^=g[N+7]<<24;case 7:D^=g[N+6]<<16;case 6:D^=g[N+5]<<8;case 5:D^=g[N+4],D=u(D,G),D=l(D,16),D=u(D,Y),v^=D;case 4:S^=g[N+3]<<24;case 3:S^=g[N+2]<<16;case 2:S^=g[N+1]<<8;case 1:S^=g[N],S=u(S,V),S=l(S,15),S=u(S,G),x^=S}return x^=g.length,v^=g.length,E^=g.length,A^=g.length,x+=v,x+=E,x+=A,v+=x,E+=x,A+=x,x=h(x),v=h(v),E=h(E),A=h(A),x+=v,x+=E,x+=A,v+=x,E+=x,A+=x,("00000000"+(x>>>0).toString(16)).slice(-8)+("00000000"+(v>>>0).toString(16)).slice(-8)+("00000000"+(E>>>0).toString(16)).slice(-8)+("00000000"+(A>>>0).toString(16)).slice(-8)},o.x64.hash128=function(g,B){if(o.inputValidation&&!s(g))return n;B=B||0;for(var k=g.length%16,R=g.length-k,x=[0,B],v=[0,B],E=[0,0],A=[0,0],S=[2277735313,289559509],D=[1291169091,658871167],I=0;I<R;I=I+16)E=[g[I+4]|g[I+5]<<8|g[I+6]<<16|g[I+7]<<24,g[I]|g[I+1]<<8|g[I+2]<<16|g[I+3]<<24],A=[g[I+12]|g[I+13]<<8|g[I+14]<<16|g[I+15]<<24,g[I+8]|g[I+9]<<8|g[I+10]<<16|g[I+11]<<24],E=p(E,S),E=b(E,31),E=p(E,D),x=T(x,E),x=b(x,27),x=d(x,v),x=d(p(x,[0,5]),[0,1390208809]),A=p(A,D),A=b(A,33),A=p(A,S),v=T(v,A),v=b(v,31),v=d(v,x),v=d(p(v,[0,5]),[0,944331445]);switch(E=[0,0],A=[0,0],k){case 15:A=T(A,_([0,g[I+14]],48));case 14:A=T(A,_([0,g[I+13]],40));case 13:A=T(A,_([0,g[I+12]],32));case 12:A=T(A,_([0,g[I+11]],24));case 11:A=T(A,_([0,g[I+10]],16));case 10:A=T(A,_([0,g[I+9]],8));case 9:A=T(A,[0,g[I+8]]),A=p(A,D),A=b(A,33),A=p(A,S),v=T(v,A);case 8:E=T(E,_([0,g[I+7]],56));case 7:E=T(E,_([0,g[I+6]],48));case 6:E=T(E,_([0,g[I+5]],40));case 5:E=T(E,_([0,g[I+4]],32));case 4:E=T(E,_([0,g[I+3]],24));case 3:E=T(E,_([0,g[I+2]],16));case 2:E=T(E,_([0,g[I+1]],8));case 1:E=T(E,[0,g[I]]),E=p(E,S),E=b(E,31),E=p(E,D),x=T(x,E)}return x=T(x,[0,g.length]),v=T(v,[0,g.length]),x=d(x,v),v=d(v,x),x=C(x),v=C(v),x=d(x,v),v=d(v,x),("00000000"+(x[0]>>>0).toString(16)).slice(-8)+("00000000"+(x[1]>>>0).toString(16)).slice(-8)+("00000000"+(v[0]>>>0).toString(16)).slice(-8)+("00000000"+(v[1]>>>0).toString(16)).slice(-8)},t.exports&&(e=t.exports=o),e.murmurHash3=o})()})(murmurHash3js,murmurHash3js.exports);var murmurhash3jsRevisited=murmurHash3js.exports;function fromNumberTo32BitBuf(t){const e=new Array(4);for(let r=0;r<4;r++)e[r]=t&255,t=t>>8;return new Uint8Array(e)}from({name:"murmur3-32",code:35,encode:t=>fromNumberTo32BitBuf(murmurhash3jsRevisited.x86.hash32(t))});const murmur3128=from({name:"murmur3-128",code:34,encode:t=>fromHex(murmurhash3jsRevisited.x64.hash128(t))});async function hamtHashFn(t){return(await murmur3128.encode(t)).slice(0,8).reverse()}const defaultOptions={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hasher:sha256,leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:17437180132763652,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,recursive:!1,hidden:!1,timeout:void 0,hamtHashFn,hamtHashCode:34,hamtBucketBits:8};var defaultOptions$1=(t={})=>mergeOptions.bind({ignoreUndefined:!0})(defaultOptions,t);function assign(t,e){for(const r in e)Object.defineProperty(t,r,{value:e[r],enumerable:!0,configurable:!0});return t}function createError(t,e,r){if(!t||typeof t=="string")throw new TypeError("Please pass an Error to err-code");r||(r={}),typeof e=="object"&&(r=e,e=""),e&&(r.code=e);try{return assign(t,r)}catch{r.message=t.message,r.stack=t.stack;const o=function(){};return o.prototype=Object.create(Object.getPrototypeOf(t)),assign(new o,r)}}var errCode$3=createError,indexMinimal={},minimal$1={},aspromise=asPromise;function asPromise(t,e){for(var r=new Array(arguments.length-1),n=0,o=2,s=!0;o<arguments.length;)r[n++]=arguments[o++];return new Promise(function(l,h){r[n]=function(p){if(s)if(s=!1,p)h(p);else{for(var b=new Array(arguments.length-1),_=0;_<b.length;)b[_++]=arguments[_];l.apply(null,b)}};try{t.apply(e||null,r)}catch(d){s&&(s=!1,h(d))}})}var base64$3={};(function(t){var e=t;e.length=function(l){var h=l.length;if(!h)return 0;for(var d=0;--h%4>1&&l.charAt(h)==="=";)++d;return Math.ceil(l.length*3)/4-d};for(var r=new Array(64),n=new Array(123),o=0;o<64;)n[r[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;e.encode=function(l,h,d){for(var p=null,b=[],_=0,T=0,C;h<d;){var g=l[h++];switch(T){case 0:b[_++]=r[g>>2],C=(g&3)<<4,T=1;break;case 1:b[_++]=r[C|g>>4],C=(g&15)<<2,T=2;break;case 2:b[_++]=r[C|g>>6],b[_++]=r[g&63],T=0;break}_>8191&&((p||(p=[])).push(String.fromCharCode.apply(String,b)),_=0)}return T&&(b[_++]=r[C],b[_++]=61,T===1&&(b[_++]=61)),p?(_&&p.push(String.fromCharCode.apply(String,b.slice(0,_))),p.join("")):String.fromCharCode.apply(String,b.slice(0,_))};var s="invalid encoding";e.decode=function(l,h,d){for(var p=d,b=0,_,T=0;T<l.length;){var C=l.charCodeAt(T++);if(C===61&&b>1)break;if((C=n[C])===void 0)throw Error(s);switch(b){case 0:_=C,b=1;break;case 1:h[d++]=_<<2|(C&48)>>4,_=C,b=2;break;case 2:h[d++]=(_&15)<<4|(C&60)>>2,_=C,b=3;break;case 3:h[d++]=(_&3)<<6|C,b=0;break}}if(b===1)throw Error(s);return d-p},e.test=function(l){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(l)}})(base64$3);var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(e,r,n){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:r,ctx:n||this}),this};EventEmitter.prototype.off=function(e,r){if(e===void 0)this._listeners={};else if(r===void 0)this._listeners[e]=[];else for(var n=this._listeners[e],o=0;o<n.length;)n[o].fn===r?n.splice(o,1):++o;return this};EventEmitter.prototype.emit=function(e){var r=this._listeners[e];if(r){for(var n=[],o=1;o<arguments.length;)n.push(arguments[o++]);for(o=0;o<r.length;)r[o].fn.apply(r[o++].ctx,n)}return this};var float=factory(factory);function factory(t){return typeof Float32Array!="undefined"?function(){var e=new Float32Array([-0]),r=new Uint8Array(e.buffer),n=r[3]===128;function o(h,d,p){e[0]=h,d[p]=r[0],d[p+1]=r[1],d[p+2]=r[2],d[p+3]=r[3]}function s(h,d,p){e[0]=h,d[p]=r[3],d[p+1]=r[2],d[p+2]=r[1],d[p+3]=r[0]}t.writeFloatLE=n?o:s,t.writeFloatBE=n?s:o;function u(h,d){return r[0]=h[d],r[1]=h[d+1],r[2]=h[d+2],r[3]=h[d+3],e[0]}function l(h,d){return r[3]=h[d],r[2]=h[d+1],r[1]=h[d+2],r[0]=h[d+3],e[0]}t.readFloatLE=n?u:l,t.readFloatBE=n?l:u}():function(){function e(n,o,s,u){var l=o<0?1:0;if(l&&(o=-o),o===0)n(1/o>0?0:2147483648,s,u);else if(isNaN(o))n(2143289344,s,u);else if(o>34028234663852886e22)n((l<<31|2139095040)>>>0,s,u);else if(o<11754943508222875e-54)n((l<<31|Math.round(o/1401298464324817e-60))>>>0,s,u);else{var h=Math.floor(Math.log(o)/Math.LN2),d=Math.round(o*Math.pow(2,-h)*8388608)&8388607;n((l<<31|h+127<<23|d)>>>0,s,u)}}t.writeFloatLE=e.bind(null,writeUintLE),t.writeFloatBE=e.bind(null,writeUintBE);function r(n,o,s){var u=n(o,s),l=(u>>31)*2+1,h=u>>>23&255,d=u&8388607;return h===255?d?NaN:l*(1/0):h===0?l*1401298464324817e-60*d:l*Math.pow(2,h-150)*(d+8388608)}t.readFloatLE=r.bind(null,readUintLE),t.readFloatBE=r.bind(null,readUintBE)}(),typeof Float64Array!="undefined"?function(){var e=new Float64Array([-0]),r=new Uint8Array(e.buffer),n=r[7]===128;function o(h,d,p){e[0]=h,d[p]=r[0],d[p+1]=r[1],d[p+2]=r[2],d[p+3]=r[3],d[p+4]=r[4],d[p+5]=r[5],d[p+6]=r[6],d[p+7]=r[7]}function s(h,d,p){e[0]=h,d[p]=r[7],d[p+1]=r[6],d[p+2]=r[5],d[p+3]=r[4],d[p+4]=r[3],d[p+5]=r[2],d[p+6]=r[1],d[p+7]=r[0]}t.writeDoubleLE=n?o:s,t.writeDoubleBE=n?s:o;function u(h,d){return r[0]=h[d],r[1]=h[d+1],r[2]=h[d+2],r[3]=h[d+3],r[4]=h[d+4],r[5]=h[d+5],r[6]=h[d+6],r[7]=h[d+7],e[0]}function l(h,d){return r[7]=h[d],r[6]=h[d+1],r[5]=h[d+2],r[4]=h[d+3],r[3]=h[d+4],r[2]=h[d+5],r[1]=h[d+6],r[0]=h[d+7],e[0]}t.readDoubleLE=n?u:l,t.readDoubleBE=n?l:u}():function(){function e(n,o,s,u,l,h){var d=u<0?1:0;if(d&&(u=-u),u===0)n(0,l,h+o),n(1/u>0?0:2147483648,l,h+s);else if(isNaN(u))n(0,l,h+o),n(2146959360,l,h+s);else if(u>17976931348623157e292)n(0,l,h+o),n((d<<31|2146435072)>>>0,l,h+s);else{var p;if(u<22250738585072014e-324)p=u/5e-324,n(p>>>0,l,h+o),n((d<<31|p/4294967296)>>>0,l,h+s);else{var b=Math.floor(Math.log(u)/Math.LN2);b===1024&&(b=1023),p=u*Math.pow(2,-b),n(p*4503599627370496>>>0,l,h+o),n((d<<31|b+1023<<20|p*1048576&1048575)>>>0,l,h+s)}}}t.writeDoubleLE=e.bind(null,writeUintLE,0,4),t.writeDoubleBE=e.bind(null,writeUintBE,4,0);function r(n,o,s,u,l){var h=n(u,l+o),d=n(u,l+s),p=(d>>31)*2+1,b=d>>>20&2047,_=4294967296*(d&1048575)+h;return b===2047?_?NaN:p*(1/0):b===0?p*5e-324*_:p*Math.pow(2,b-1075)*(_+4503599627370496)}t.readDoubleLE=r.bind(null,readUintLE,0,4),t.readDoubleBE=r.bind(null,readUintBE,4,0)}(),t}function writeUintLE(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}function writeUintBE(t,e,r){e[r]=t>>>24,e[r+1]=t>>>16&255,e[r+2]=t>>>8&255,e[r+3]=t&255}function readUintLE(t,e){return(t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24)>>>0}function readUintBE(t,e){return(t[e]<<24|t[e+1]<<16|t[e+2]<<8|t[e+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}var utf8$2={};(function(t){var e=t;e.length=function(n){for(var o=0,s=0,u=0;u<n.length;++u)s=n.charCodeAt(u),s<128?o+=1:s<2048?o+=2:(s&64512)==55296&&(n.charCodeAt(u+1)&64512)==56320?(++u,o+=4):o+=3;return o},e.read=function(n,o,s){var u=s-o;if(u<1)return"";for(var l=null,h=[],d=0,p;o<s;)p=n[o++],p<128?h[d++]=p:p>191&&p<224?h[d++]=(p&31)<<6|n[o++]&63:p>239&&p<365?(p=((p&7)<<18|(n[o++]&63)<<12|(n[o++]&63)<<6|n[o++]&63)-65536,h[d++]=55296+(p>>10),h[d++]=56320+(p&1023)):h[d++]=(p&15)<<12|(n[o++]&63)<<6|n[o++]&63,d>8191&&((l||(l=[])).push(String.fromCharCode.apply(String,h)),d=0);return l?(d&&l.push(String.fromCharCode.apply(String,h.slice(0,d))),l.join("")):String.fromCharCode.apply(String,h.slice(0,d))},e.write=function(n,o,s){for(var u=s,l,h,d=0;d<n.length;++d)l=n.charCodeAt(d),l<128?o[s++]=l:l<2048?(o[s++]=l>>6|192,o[s++]=l&63|128):(l&64512)==55296&&((h=n.charCodeAt(d+1))&64512)==56320?(l=65536+((l&1023)<<10)+(h&1023),++d,o[s++]=l>>18|240,o[s++]=l>>12&63|128,o[s++]=l>>6&63|128,o[s++]=l&63|128):(o[s++]=l>>12|224,o[s++]=l>>6&63|128,o[s++]=l&63|128);return s-u}})(utf8$2);var pool_1=pool;function pool(t,e,r){var n=r||8192,o=n>>>1,s=null,u=n;return function(h){if(h<1||h>o)return t(h);u+h>n&&(s=t(n),u=0);var d=e.call(s,u,u+=h);return u&7&&(u=(u|7)+1),d}}var longbits=LongBits$2,util$5=minimal$1;function LongBits$2(t,e){this.lo=t>>>0,this.hi=e>>>0}var zero=LongBits$2.zero=new LongBits$2(0,0);zero.toNumber=function(){return 0};zero.zzEncode=zero.zzDecode=function(){return this};zero.length=function(){return 1};var zeroHash=LongBits$2.zeroHash="\0\0\0\0\0\0\0\0";LongBits$2.fromNumber=function t(e){if(e===0)return zero;var r=e<0;r&&(e=-e);var n=e>>>0,o=(e-n)/4294967296>>>0;return r&&(o=~o>>>0,n=~n>>>0,++n>4294967295&&(n=0,++o>4294967295&&(o=0))),new LongBits$2(n,o)};LongBits$2.from=function t(e){if(typeof e=="number")return LongBits$2.fromNumber(e);if(util$5.isString(e))if(util$5.Long)e=util$5.Long.fromString(e);else return LongBits$2.fromNumber(parseInt(e,10));return e.low||e.high?new LongBits$2(e.low>>>0,e.high>>>0):zero};LongBits$2.prototype.toNumber=function t(e){if(!e&&this.hi>>>31){var r=~this.lo+1>>>0,n=~this.hi>>>0;return r||(n=n+1>>>0),-(r+n*4294967296)}return this.lo+this.hi*4294967296};LongBits$2.prototype.toLong=function t(e){return util$5.Long?new util$5.Long(this.lo|0,this.hi|0,Boolean(e)):{low:this.lo|0,high:this.hi|0,unsigned:Boolean(e)}};var charCodeAt=String.prototype.charCodeAt;LongBits$2.fromHash=function t(e){return e===zeroHash?zero:new LongBits$2((charCodeAt.call(e,0)|charCodeAt.call(e,1)<<8|charCodeAt.call(e,2)<<16|charCodeAt.call(e,3)<<24)>>>0,(charCodeAt.call(e,4)|charCodeAt.call(e,5)<<8|charCodeAt.call(e,6)<<16|charCodeAt.call(e,7)<<24)>>>0)};LongBits$2.prototype.toHash=function t(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)};LongBits$2.prototype.zzEncode=function t(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this};LongBits$2.prototype.zzDecode=function t(){var e=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this};LongBits$2.prototype.length=function t(){var e=this.lo,r=(this.lo>>>28|this.hi<<4)>>>0,n=this.hi>>>24;return n===0?r===0?e<16384?e<128?1:2:e<2097152?3:4:r<16384?r<128?5:6:r<2097152?7:8:n<128?9:10};(function(t){var e=t;e.asPromise=aspromise,e.base64=base64$3,e.EventEmitter=eventemitter,e.float=float,e.inquire=inquire_1,e.utf8=utf8$2,e.pool=pool_1,e.LongBits=longbits,e.isNode=Boolean(typeof commonjsGlobal!="undefined"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),e.global=e.isNode&&commonjsGlobal||typeof window!="undefined"&&window||typeof self!="undefined"&&self||commonjsGlobal,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(s){return typeof s=="number"&&isFinite(s)&&Math.floor(s)===s},e.isString=function(s){return typeof s=="string"||s instanceof String},e.isObject=function(s){return s&&typeof s=="object"},e.isset=e.isSet=function(s,u){var l=s[u];return l!=null&&s.hasOwnProperty(u)?typeof l!="object"||(Array.isArray(l)?l.length:Object.keys(l).length)>0:!1},e.Buffer=function(){try{var o=e.inquire("buffer").Buffer;return o.prototype.utf8Write?o:null}catch{return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(s){return typeof s=="number"?e.Buffer?e._Buffer_allocUnsafe(s):new e.Array(s):e.Buffer?e._Buffer_from(s):typeof Uint8Array=="undefined"?s:new Uint8Array(s)},e.Array=typeof Uint8Array!="undefined"?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(s){return s?e.LongBits.from(s).toHash():e.LongBits.zeroHash},e.longFromHash=function(s,u){var l=e.LongBits.fromHash(s);return e.Long?e.Long.fromBits(l.lo,l.hi,u):l.toNumber(Boolean(u))};function r(o,s,u){for(var l=Object.keys(s),h=0;h<l.length;++h)(o[l[h]]===void 0||!u)&&(o[l[h]]=s[l[h]]);return o}e.merge=r,e.lcFirst=function(s){return s.charAt(0).toLowerCase()+s.substring(1)};function n(o){function s(u,l){if(!(this instanceof s))return new s(u,l);Object.defineProperty(this,"message",{get:function(){return u}}),Error.captureStackTrace?Error.captureStackTrace(this,s):Object.defineProperty(this,"stack",{value:new Error().stack||""}),l&&r(this,l)}return(s.prototype=Object.create(Error.prototype)).constructor=s,Object.defineProperty(s.prototype,"name",{get:function(){return o}}),s.prototype.toString=function(){return this.name+": "+this.message},s}e.newError=n,e.ProtocolError=n("ProtocolError"),e.oneOfGetter=function(s){for(var u={},l=0;l<s.length;++l)u[s[l]]=1;return function(){for(var h=Object.keys(this),d=h.length-1;d>-1;--d)if(u[h[d]]===1&&this[h[d]]!==void 0&&this[h[d]]!==null)return h[d]}},e.oneOfSetter=function(s){return function(u){for(var l=0;l<s.length;++l)s[l]!==u&&delete this[s[l]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var o=e.Buffer;if(!o){e._Buffer_from=e._Buffer_allocUnsafe=null;return}e._Buffer_from=o.from!==Uint8Array.from&&o.from||function(u,l){return new o(u,l)},e._Buffer_allocUnsafe=o.allocUnsafe||function(u){return new o(u)}}})(minimal$1);var writer=Writer$1,util$4=minimal$1,BufferWriter$1,LongBits$1=util$4.LongBits,base64$2=util$4.base64,utf8$1=util$4.utf8;function Op(t,e,r){this.fn=t,this.len=e,this.next=void 0,this.val=r}function noop(){}function State(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$2=function t(){return util$4.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create$2();Writer$1.alloc=function t(e){return new util$4.Array(e)};util$4.Array!==Array&&(Writer$1.alloc=util$4.pool(Writer$1.alloc,util$4.Array.prototype.subarray));Writer$1.prototype._push=function t(e,r,n){return this.tail=this.tail.next=new Op(e,r,n),this.len+=r,this};function writeByte(t,e,r){e[r]=t&255}function writeVarint32(t,e,r){for(;t>127;)e[r++]=t&127|128,t>>>=7;e[r]=t}function VarintOp(t,e){this.len=t,this.next=void 0,this.val=e}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function t(e){return this.len+=(this.tail=this.tail.next=new VarintOp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Writer$1.prototype.int32=function t(e){return e<0?this._push(writeVarint64,10,LongBits$1.fromNumber(e)):this.uint32(e)};Writer$1.prototype.sint32=function t(e){return this.uint32((e<<1^e>>31)>>>0)};function writeVarint64(t,e,r){for(;t.hi;)e[r++]=t.lo&127|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=t.lo&127|128,t.lo=t.lo>>>7;e[r++]=t.lo}Writer$1.prototype.uint64=function t(e){var r=LongBits$1.from(e);return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function t(e){var r=LongBits$1.from(e).zzEncode();return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.bool=function t(e){return this._push(writeByte,1,e?1:0)};function writeFixed32(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}Writer$1.prototype.fixed32=function t(e){return this._push(writeFixed32,4,e>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function t(e){var r=LongBits$1.from(e);return this._push(writeFixed32,4,r.lo)._push(writeFixed32,4,r.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function t(e){return this._push(util$4.float.writeFloatLE,4,e)};Writer$1.prototype.double=function t(e){return this._push(util$4.float.writeDoubleLE,8,e)};var writeBytes=util$4.Array.prototype.set?function t(e,r,n){r.set(e,n)}:function t(e,r,n){for(var o=0;o<e.length;++o)r[n+o]=e[o]};Writer$1.prototype.bytes=function t(e){var r=e.length>>>0;if(!r)return this._push(writeByte,1,0);if(util$4.isString(e)){var n=Writer$1.alloc(r=base64$2.length(e));base64$2.decode(e,n,0),e=n}return this.uint32(r)._push(writeBytes,r,e)};Writer$1.prototype.string=function t(e){var r=utf8$1.length(e);return r?this.uint32(r)._push(utf8$1.write,r,e):this._push(writeByte,1,0)};Writer$1.prototype.fork=function t(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this};Writer$1.prototype.reset=function t(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this};Writer$1.prototype.ldelim=function t(){var e=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=r,this.len+=n),this};Writer$1.prototype.finish=function t(){for(var e=this.head.next,r=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,r,n),n+=e.len,e=e.next;return r};Writer$1._configure=function(t){BufferWriter$1=t,Writer$1.create=create$2(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$3=minimal$1;function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3.Buffer&&util$3.Buffer.prototype instanceof Uint8Array&&util$3.Buffer.prototype.set.name==="set"?function(e,r,n){r.set(e,n)}:function(e,r,n){if(e.copy)e.copy(r,n,0,e.length);else for(var o=0;o<e.length;)r[n++]=e[o++]}};BufferWriter.prototype.bytes=function t(e){util$3.isString(e)&&(e=util$3._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(BufferWriter.writeBytesBuffer,r,e),this};function writeStringBuffer(t,e,r){t.length<40?util$3.utf8.write(t,e,r):e.utf8Write?e.utf8Write(t,r):e.write(t,r)}BufferWriter.prototype.string=function t(e){var r=util$3.Buffer.byteLength(e);return this.uint32(r),r&&this._push(writeStringBuffer,r,e),this};BufferWriter._configure();var reader=Reader$1,util$2=minimal$1,BufferReader$1,LongBits=util$2.LongBits,utf8=util$2.utf8;function indexOutOfRange(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function Reader$1(t){this.buf=t,this.pos=0,this.len=t.length}var create_array=typeof Uint8Array!="undefined"?function t(e){if(e instanceof Uint8Array||Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")}:function t(e){if(Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")},create$1=function t(){return util$2.Buffer?function(r){return(Reader$1.create=function(o){return util$2.Buffer.isBuffer(o)?new BufferReader$1(o):create_array(o)})(r)}:create_array};Reader$1.create=create$1();Reader$1.prototype._slice=util$2.Array.prototype.subarray||util$2.Array.prototype.slice;Reader$1.prototype.uint32=function t(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return e}}();Reader$1.prototype.int32=function t(){return this.uint32()|0};Reader$1.prototype.sint32=function t(){var e=this.uint32();return e>>>1^-(e&1)|0};function readLongVarint(){var t=new LongBits(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function t(){return this.uint32()!==0};function readFixed32_end(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}Reader$1.prototype.fixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};Reader$1.prototype.double=function t(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};Reader$1.prototype.bytes=function t(){var e=this.uint32(),r=this.pos,n=this.pos+e;if(n>this.len)throw indexOutOfRange(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(r,n):r===n?new this.buf.constructor(0):this._slice.call(this.buf,r,n)};Reader$1.prototype.string=function t(){var e=this.bytes();return utf8.read(e,0,e.length)};Reader$1.prototype.skip=function t(e){if(typeof e=="number"){if(this.pos+e>this.len)throw indexOutOfRange(this,e);this.pos+=e}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!=4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this};Reader$1._configure=function(t){BufferReader$1=t,Reader$1.create=create$1(),BufferReader$1._configure();var e=util$2.Long?"toLong":"toNumber";util$2.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[e](!1)},uint64:function(){return readLongVarint.call(this)[e](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[e](!1)},fixed64:function(){return readFixed64.call(this)[e](!0)},sfixed64:function(){return readFixed64.call(this)[e](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$1=minimal$1;function BufferReader(t){Reader.call(this,t)}BufferReader._configure=function(){util$1.Buffer&&(BufferReader.prototype._slice=util$1.Buffer.prototype.slice)};BufferReader.prototype.string=function t(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};BufferReader._configure();var rpc={},service=Service,util=minimal$1;(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service;function Service(t,e,r){if(typeof t!="function")throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=Boolean(e),this.responseDelimited=Boolean(r)}Service.prototype.rpcCall=function t(e,r,n,o,s){if(!o)throw TypeError("request must be specified");var u=this;if(!s)return util.asPromise(t,u,e,r,n,o);if(!u.rpcImpl){setTimeout(function(){s(Error("already ended"))},0);return}try{return u.rpcImpl(e,r[u.requestDelimited?"encodeDelimited":"encode"](o).finish(),function(h,d){if(h)return u.emit("error",h,e),s(h);if(d===null){u.end(!0);return}if(!(d instanceof n))try{d=n[u.responseDelimited?"decodeDelimited":"decode"](d)}catch(p){return u.emit("error",p,e),s(p)}return u.emit("data",d,e),s(null,d)})}catch(l){u.emit("error",l,e),setTimeout(function(){s(l)},0);return}};Service.prototype.end=function t(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};(function(t){var e=t;e.Service=service})(rpc);var roots={};(function(t){var e=t;e.build="minimal",e.Writer=writer,e.BufferWriter=writer_buffer,e.Reader=reader,e.BufferReader=reader_buffer,e.util=minimal$1,e.rpc=rpc,e.roots=roots,e.configure=r;function r(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}r()})(indexMinimal);var minimal=indexMinimal;const $Reader=minimal.Reader,$Writer=minimal.Writer,$util=minimal.util,$root=minimal.roots["ipfs-unixfs"]||(minimal.roots["ipfs-unixfs"]={}),Data=$root.Data=(()=>{function t(e){if(this.blocksizes=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Type=0,t.prototype.Data=$util.newBuffer([]),t.prototype.filesize=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.blocksizes=$util.emptyArray,t.prototype.hashType=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.fanout=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.mode=0,t.prototype.mtime=null,t.encode=function(r,n){if(n||(n=$Writer.create()),n.uint32(8).int32(r.Type),r.Data!=null&&Object.hasOwnProperty.call(r,"Data")&&n.uint32(18).bytes(r.Data),r.filesize!=null&&Object.hasOwnProperty.call(r,"filesize")&&n.uint32(24).uint64(r.filesize),r.blocksizes!=null&&r.blocksizes.length)for(var o=0;o<r.blocksizes.length;++o)n.uint32(32).uint64(r.blocksizes[o]);return r.hashType!=null&&Object.hasOwnProperty.call(r,"hashType")&&n.uint32(40).uint64(r.hashType),r.fanout!=null&&Object.hasOwnProperty.call(r,"fanout")&&n.uint32(48).uint64(r.fanout),r.mode!=null&&Object.hasOwnProperty.call(r,"mode")&&n.uint32(56).uint32(r.mode),r.mtime!=null&&Object.hasOwnProperty.call(r,"mtime")&&$root.UnixTime.encode(r.mtime,n.uint32(66).fork()).ldelim(),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.Data;r.pos<o;){var u=r.uint32();switch(u>>>3){case 1:s.Type=r.int32();break;case 2:s.Data=r.bytes();break;case 3:s.filesize=r.uint64();break;case 4:if(s.blocksizes&&s.blocksizes.length||(s.blocksizes=[]),(u&7)==2)for(var l=r.uint32()+r.pos;r.pos<l;)s.blocksizes.push(r.uint64());else s.blocksizes.push(r.uint64());break;case 5:s.hashType=r.uint64();break;case 6:s.fanout=r.uint64();break;case 7:s.mode=r.uint32();break;case 8:s.mtime=$root.UnixTime.decode(r,r.uint32());break;default:r.skipType(u&7);break}}if(!s.hasOwnProperty("Type"))throw $util.ProtocolError("missing required 'Type'",{instance:s});return s},t.fromObject=function(r){if(r instanceof $root.Data)return r;var n=new $root.Data;switch(r.Type){case"Raw":case 0:n.Type=0;break;case"Directory":case 1:n.Type=1;break;case"File":case 2:n.Type=2;break;case"Metadata":case 3:n.Type=3;break;case"Symlink":case 4:n.Type=4;break;case"HAMTShard":case 5:n.Type=5;break}if(r.Data!=null&&(typeof r.Data=="string"?$util.base64.decode(r.Data,n.Data=$util.newBuffer($util.base64.length(r.Data)),0):r.Data.length&&(n.Data=r.Data)),r.filesize!=null&&($util.Long?(n.filesize=$util.Long.fromValue(r.filesize)).unsigned=!0:typeof r.filesize=="string"?n.filesize=parseInt(r.filesize,10):typeof r.filesize=="number"?n.filesize=r.filesize:typeof r.filesize=="object"&&(n.filesize=new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0))),r.blocksizes){if(!Array.isArray(r.blocksizes))throw TypeError(".Data.blocksizes: array expected");n.blocksizes=[];for(var o=0;o<r.blocksizes.length;++o)$util.Long?(n.blocksizes[o]=$util.Long.fromValue(r.blocksizes[o])).unsigned=!0:typeof r.blocksizes[o]=="string"?n.blocksizes[o]=parseInt(r.blocksizes[o],10):typeof r.blocksizes[o]=="number"?n.blocksizes[o]=r.blocksizes[o]:typeof r.blocksizes[o]=="object"&&(n.blocksizes[o]=new $util.LongBits(r.blocksizes[o].low>>>0,r.blocksizes[o].high>>>0).toNumber(!0))}if(r.hashType!=null&&($util.Long?(n.hashType=$util.Long.fromValue(r.hashType)).unsigned=!0:typeof r.hashType=="string"?n.hashType=parseInt(r.hashType,10):typeof r.hashType=="number"?n.hashType=r.hashType:typeof r.hashType=="object"&&(n.hashType=new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0))),r.fanout!=null&&($util.Long?(n.fanout=$util.Long.fromValue(r.fanout)).unsigned=!0:typeof r.fanout=="string"?n.fanout=parseInt(r.fanout,10):typeof r.fanout=="number"?n.fanout=r.fanout:typeof r.fanout=="object"&&(n.fanout=new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0))),r.mode!=null&&(n.mode=r.mode>>>0),r.mtime!=null){if(typeof r.mtime!="object")throw TypeError(".Data.mtime: object expected");n.mtime=$root.UnixTime.fromObject(r.mtime)}return n},t.toObject=function(r,n){n||(n={});var o={};if((n.arrays||n.defaults)&&(o.blocksizes=[]),n.defaults){if(o.Type=n.enums===String?"Raw":0,n.bytes===String?o.Data="":(o.Data=[],n.bytes!==Array&&(o.Data=$util.newBuffer(o.Data))),$util.Long){var s=new $util.Long(0,0,!0);o.filesize=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.filesize=n.longs===String?"0":0;if($util.Long){var s=new $util.Long(0,0,!0);o.hashType=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.hashType=n.longs===String?"0":0;if($util.Long){var s=new $util.Long(0,0,!0);o.fanout=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.fanout=n.longs===String?"0":0;o.mode=0,o.mtime=null}if(r.Type!=null&&r.hasOwnProperty("Type")&&(o.Type=n.enums===String?$root.Data.DataType[r.Type]:r.Type),r.Data!=null&&r.hasOwnProperty("Data")&&(o.Data=n.bytes===String?$util.base64.encode(r.Data,0,r.Data.length):n.bytes===Array?Array.prototype.slice.call(r.Data):r.Data),r.filesize!=null&&r.hasOwnProperty("filesize")&&(typeof r.filesize=="number"?o.filesize=n.longs===String?String(r.filesize):r.filesize:o.filesize=n.longs===String?$util.Long.prototype.toString.call(r.filesize):n.longs===Number?new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0):r.filesize),r.blocksizes&&r.blocksizes.length){o.blocksizes=[];for(var u=0;u<r.blocksizes.length;++u)typeof r.blocksizes[u]=="number"?o.blocksizes[u]=n.longs===String?String(r.blocksizes[u]):r.blocksizes[u]:o.blocksizes[u]=n.longs===String?$util.Long.prototype.toString.call(r.blocksizes[u]):n.longs===Number?new $util.LongBits(r.blocksizes[u].low>>>0,r.blocksizes[u].high>>>0).toNumber(!0):r.blocksizes[u]}return r.hashType!=null&&r.hasOwnProperty("hashType")&&(typeof r.hashType=="number"?o.hashType=n.longs===String?String(r.hashType):r.hashType:o.hashType=n.longs===String?$util.Long.prototype.toString.call(r.hashType):n.longs===Number?new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0):r.hashType),r.fanout!=null&&r.hasOwnProperty("fanout")&&(typeof r.fanout=="number"?o.fanout=n.longs===String?String(r.fanout):r.fanout:o.fanout=n.longs===String?$util.Long.prototype.toString.call(r.fanout):n.longs===Number?new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0):r.fanout),r.mode!=null&&r.hasOwnProperty("mode")&&(o.mode=r.mode),r.mtime!=null&&r.hasOwnProperty("mtime")&&(o.mtime=$root.UnixTime.toObject(r.mtime,n)),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},t.DataType=function(){const e={},r=Object.create(e);return r[e[0]="Raw"]=0,r[e[1]="Directory"]=1,r[e[2]="File"]=2,r[e[3]="Metadata"]=3,r[e[4]="Symlink"]=4,r[e[5]="HAMTShard"]=5,r}(),t})();$root.UnixTime=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.FractionalNanoseconds=0,t.encode=function(r,n){return n||(n=$Writer.create()),n.uint32(8).int64(r.Seconds),r.FractionalNanoseconds!=null&&Object.hasOwnProperty.call(r,"FractionalNanoseconds")&&n.uint32(21).fixed32(r.FractionalNanoseconds),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.UnixTime;r.pos<o;){var u=r.uint32();switch(u>>>3){case 1:s.Seconds=r.int64();break;case 2:s.FractionalNanoseconds=r.fixed32();break;default:r.skipType(u&7);break}}if(!s.hasOwnProperty("Seconds"))throw $util.ProtocolError("missing required 'Seconds'",{instance:s});return s},t.fromObject=function(r){if(r instanceof $root.UnixTime)return r;var n=new $root.UnixTime;return r.Seconds!=null&&($util.Long?(n.Seconds=$util.Long.fromValue(r.Seconds)).unsigned=!1:typeof r.Seconds=="string"?n.Seconds=parseInt(r.Seconds,10):typeof r.Seconds=="number"?n.Seconds=r.Seconds:typeof r.Seconds=="object"&&(n.Seconds=new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber())),r.FractionalNanoseconds!=null&&(n.FractionalNanoseconds=r.FractionalNanoseconds>>>0),n},t.toObject=function(r,n){n||(n={});var o={};if(n.defaults){if($util.Long){var s=new $util.Long(0,0,!1);o.Seconds=n.longs===String?s.toString():n.longs===Number?s.toNumber():s}else o.Seconds=n.longs===String?"0":0;o.FractionalNanoseconds=0}return r.Seconds!=null&&r.hasOwnProperty("Seconds")&&(typeof r.Seconds=="number"?o.Seconds=n.longs===String?String(r.Seconds):r.Seconds:o.Seconds=n.longs===String?$util.Long.prototype.toString.call(r.Seconds):n.longs===Number?new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber():r.Seconds),r.FractionalNanoseconds!=null&&r.hasOwnProperty("FractionalNanoseconds")&&(o.FractionalNanoseconds=r.FractionalNanoseconds),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},t})();$root.Metadata=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.MimeType="",t.encode=function(r,n){return n||(n=$Writer.create()),r.MimeType!=null&&Object.hasOwnProperty.call(r,"MimeType")&&n.uint32(10).string(r.MimeType),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var o=n===void 0?r.len:r.pos+n,s=new $root.Metadata;r.pos<o;){var u=r.uint32();switch(u>>>3){case 1:s.MimeType=r.string();break;default:r.skipType(u&7);break}}return s},t.fromObject=function(r){if(r instanceof $root.Metadata)return r;var n=new $root.Metadata;return r.MimeType!=null&&(n.MimeType=String(r.MimeType)),n},t.toObject=function(r,n){n||(n={});var o={};return n.defaults&&(o.MimeType=""),r.MimeType!=null&&r.hasOwnProperty("MimeType")&&(o.MimeType=r.MimeType),o},t.prototype.toJSON=function(){return this.constructor.toObject(this,minimal.util.toJSONOptions)},t})();const PBData=Data,types=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],dirTypes=["directory","hamt-sharded-directory"],DEFAULT_FILE_MODE=parseInt("0644",8),DEFAULT_DIRECTORY_MODE=parseInt("0755",8);function parseMode$1(t){if(t!=null)return typeof t=="number"?t&4095:(t=t.toString(),t.substring(0,1)==="0"?parseInt(t,8)&4095:parseInt(t,10)&4095)}function parseMtime$1(t){if(t==null)return;let e;if(t.secs!=null&&(e={secs:t.secs,nsecs:t.nsecs}),t.Seconds!=null&&(e={secs:t.Seconds,nsecs:t.FractionalNanoseconds}),Array.isArray(t)&&(e={secs:t[0],nsecs:t[1]}),t instanceof Date){const r=t.getTime(),n=Math.floor(r/1e3);e={secs:n,nsecs:(r-n*1e3)*1e3}}if(!!Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw errCode$3(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}class UnixFS{static unmarshal(e){const r=PBData.decode(e),n=PBData.toObject(r,{defaults:!1,arrays:!0,longs:Number,objects:!1}),o=new UnixFS({type:types[n.Type],data:n.Data,blockSizes:n.blocksizes,mode:n.mode,mtime:n.mtime?{secs:n.mtime.Seconds,nsecs:n.mtime.FractionalNanoseconds}:void 0});return o._originalMode=n.mode||0,o}constructor(e={type:"file"}){const{type:r,data:n,blockSizes:o,hashType:s,fanout:u,mtime:l,mode:h}=e;if(r&&!types.includes(r))throw errCode$3(new Error("Type: "+r+" is not valid"),"ERR_INVALID_TYPE");this.type=r||"file",this.data=n,this.hashType=s,this.fanout=u,this.blockSizes=o||[],this._originalMode=0,this.mode=parseMode$1(h),l&&(this.mtime=parseMtime$1(l),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?DEFAULT_DIRECTORY_MODE:DEFAULT_FILE_MODE;const r=parseMode$1(e);r!==void 0&&(this._mode=r)}get mode(){return this._mode}isDirectory(){return Boolean(this.type&&dirTypes.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach(r=>{e+=r}),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=PBData.DataType.Raw;break;case"directory":e=PBData.DataType.Directory;break;case"file":e=PBData.DataType.File;break;case"metadata":e=PBData.DataType.Metadata;break;case"symlink":e=PBData.DataType.Symlink;break;case"hamt-sharded-directory":e=PBData.DataType.HAMTShard;break;default:throw errCode$3(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let r=this.data;(!this.data||!this.data.length)&&(r=void 0);let n;this.mode!=null&&(n=this._originalMode&4294963200|(parseMode$1(this.mode)||0),n===DEFAULT_FILE_MODE&&!this.isDirectory()&&(n=void 0),n===DEFAULT_DIRECTORY_MODE&&this.isDirectory()&&(n=void 0));let o;if(this.mtime!=null){const u=parseMtime$1(this.mtime);u&&(o={Seconds:u.secs,FractionalNanoseconds:u.nsecs},o.FractionalNanoseconds===0&&delete o.FractionalNanoseconds)}const s={Type:e,Data:r,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:n,mtime:o};return PBData.encode(s).finish()}}var src$3=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",parseMode:parseMode$1,parseMtime:parseMtime$1,UnixFS});const textDecoder=new TextDecoder;function decodeVarint(t,e){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(e>=t.length)throw new Error("protobuf: unexpected end of data");const o=t[e++];if(r+=n<28?(o&127)<<n:(o&127)*2**n,o<128)break}return[r,e]}function decodeBytes(t,e){let r;[r,e]=decodeVarint(t,e);const n=e+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>t.length)throw new Error("protobuf: unexpected end of data");return[t.subarray(e,n),n]}function decodeKey(t,e){let r;return[r,e]=decodeVarint(t,e),[r&7,r>>3,e]}function decodeLink(t){const e={},r=t.length;let n=0;for(;n<r;){let o,s;if([o,s,n]=decodeKey(t,n),s===1){if(e.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Hash`);if(e.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[e.Hash,n]=decodeBytes(t,n)}else if(s===2){if(e.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(o!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Name`);if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let u;[u,n]=decodeBytes(t,n),e.Name=textDecoder.decode(u)}else if(s===3){if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(o!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${o}) for Tsize`);[e.Tsize,n]=decodeVarint(t,n)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${s}`)}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return e}function decodeNode(t){const e=t.length;let r=0,n,o=!1,s;for(;r<e;){let l,h;if([l,h,r]=decodeKey(t,r),l!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${l}`);if(h===1){if(s)throw new Error("protobuf: (PBNode) duplicate Data section");[s,r]=decodeBytes(t,r),n&&(o=!0)}else if(h===2){if(o)throw new Error("protobuf: (PBNode) duplicate Links section");n||(n=[]);let d;[d,r]=decodeBytes(t,r),n.push(decodeLink(d))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${h}`)}if(r>e)throw new Error("protobuf: (PBNode) unexpected end of data");const u={};return s&&(u.Data=s),u.Links=n||[],u}const textEncoder$1=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink(t,e){let r=e.length;if(typeof t.Tsize=="number"){if(t.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(t.Tsize))throw new Error("Tsize too large for encoding");r=encodeVarint(e,r,t.Tsize)-1,e[r]=24}if(typeof t.Name=="string"){const n=textEncoder$1.encode(t.Name);r-=n.length,e.set(n,r),r=encodeVarint(e,r,n.length)-1,e[r]=18}return t.Hash&&(r-=t.Hash.length,e.set(t.Hash,r),r=encodeVarint(e,r,t.Hash.length)-1,e[r]=10),e.length-r}function encodeNode(t){const e=sizeNode(t),r=new Uint8Array(e);let n=e;if(t.Data&&(n-=t.Data.length,r.set(t.Data,n),n=encodeVarint(r,n,t.Data.length)-1,r[n]=10),t.Links)for(let o=t.Links.length-1;o>=0;o--){const s=encodeLink(t.Links[o],r.subarray(0,n));n-=s,n=encodeVarint(r,n,s)-1,r[n]=18}return r}function sizeLink(t){let e=0;if(t.Hash){const r=t.Hash.length;e+=1+r+sov(r)}if(typeof t.Name=="string"){const r=textEncoder$1.encode(t.Name).length;e+=1+r+sov(r)}return typeof t.Tsize=="number"&&(e+=1+sov(t.Tsize)),e}function sizeNode(t){let e=0;if(t.Data){const r=t.Data.length;e+=1+r+sov(r)}if(t.Links)for(const r of t.Links){const n=sizeLink(r);e+=1+n+sov(n)}return e}function encodeVarint(t,e,r){e-=sov(r);const n=e;for(;r>=maxUInt32;)t[e++]=r&127|128,r/=128;for(;r>=128;)t[e++]=r&127|128,r>>>=7;return t[e]=r,n}function sov(t){return t%2==0&&t++,Math.floor((len64(t)+6)/7)}function len64(t){let e=0;return t>=maxInt32&&(t=Math.floor(t/maxInt32),e=32),t>=1<<16&&(t>>>=16,e+=16),t>=1<<8&&(t>>>=8,e+=8),e+len8tab[t]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder=new TextEncoder;function linkComparator(t,e){if(t===e)return 0;const r=t.Name?textEncoder.encode(t.Name):[],n=e.Name?textEncoder.encode(e.Name):[];let o=r.length,s=n.length;for(let u=0,l=Math.min(o,s);u<l;++u)if(r[u]!==n[u]){o=r[u],s=n[u];break}return o<s?-1:s<o?1:0}function hasOnlyProperties(t,e){return!Object.keys(t).some(r=>!e.includes(r))}function asLink(t){if(typeof t.asCID=="object"){const r=CID$1.asCID(t);if(!r)throw new TypeError("Invalid DAG-PB form");return{Hash:r}}if(typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Hash){let r=CID$1.asCID(t.Hash);try{r||(typeof t.Hash=="string"?r=CID$1.parse(t.Hash):t.Hash instanceof Uint8Array&&(r=CID$1.decode(t.Hash)))}catch(n){throw new TypeError(`Invalid DAG-PB form: ${n.message}`)}r&&(e.Hash=r)}if(!e.Hash)throw new TypeError("Invalid DAG-PB form");return typeof t.Name=="string"&&(e.Name=t.Name),typeof t.Tsize=="number"&&(e.Tsize=t.Tsize),e}function prepare(t){if((t instanceof Uint8Array||typeof t=="string")&&(t={Data:t}),typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Data!==void 0)if(typeof t.Data=="string")e.Data=textEncoder.encode(t.Data);else if(t.Data instanceof Uint8Array)e.Data=t.Data;else throw new TypeError("Invalid DAG-PB form");if(t.Links!==void 0)if(Array.isArray(t.Links))e.Links=t.Links.map(asLink),e.Links.sort(linkComparator);else throw new TypeError("Invalid DAG-PB form");else e.Links=[];return e}function validate$1(t){if(!t||typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(t,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(t.Data!==void 0&&!(t.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(t.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let e=0;e<t.Links.length;e++){const r=t.Links[e];if(!r||typeof r!="object"||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!hasOnlyProperties(r,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(r.Name!==void 0&&typeof r.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(r.Tsize!==void 0&&(typeof r.Tsize!="number"||r.Tsize%1!=0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(e>0&&linkComparator(r,t.Links[e-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function createNode(t,e=[]){return prepare({Data:t,Links:e})}function createLink(t,e,r){return asLink({Hash:r,Name:t,Tsize:e})}const name$2="dag-pb",code$3=112;function encode$2(t){validate$1(t);const e={};return t.Links&&(e.Links=t.Links.map(r=>{const n={};return r.Hash&&(n.Hash=r.Hash.bytes),r.Name!==void 0&&(n.Name=r.Name),r.Tsize!==void 0&&(n.Tsize=r.Tsize),n})),t.Data&&(e.Data=t.Data),encodeNode(e)}function decode$2(t){const e=decodeNode(t),r={};return e.Data&&(r.Data=e.Data),e.Links&&(r.Links=e.Links.map(n=>{const o={};try{o.Hash=CID$1.decode(n.Hash)}catch{}if(!o.Hash)throw new Error("Invalid Hash field found in link, expected CID");return n.Name!==void 0&&(o.Name=n.Name),n.Tsize!==void 0&&(o.Tsize=n.Tsize),o})),r}var pb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",name:name$2,code:code$3,encode:encode$2,decode:decode$2,prepare,validate:validate$1,createNode,createLink});const persist=async(t,e,r)=>{r.codec||(r.codec=pb),r.hasher||(r.hasher=sha256),r.cidVersion===void 0&&(r.cidVersion=1),r.codec===pb&&r.hasher!==sha256&&(r.cidVersion=1);const n=await r.hasher.digest(t),o=CID$1.create(r.cidVersion,r.codec.code,n);return r.onlyHash||await e.put(o,t,{signal:r.signal}),o},dirBuilder=async(t,e,r)=>{const n=new UnixFS({type:"directory",mtime:t.mtime,mode:t.mode}),o=encode$2(prepare({Data:n.marshal()})),s=await persist(o,e,r),u=t.path;return{cid:s,path:u,unixfs:n,size:o.length}},name$1="raw",code$2=85,encode$1=t=>coerce(t),decode$1=t=>coerce(t);var raw$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",name:name$1,code:code$2,encode:encode$1,decode:decode$1});const all$2=async t=>{const e=[];for await(const r of t)e.push(r);return e};var itAll=all$2;async function flat(t,e){return e(await itAll(t))}function balanced(t,e,r){return reduceToParents(t,e,r)}async function reduceToParents(t,e,r){const n=[];for await(const o of itBatch(t,r.maxChildrenPerNode))n.push(await e(o));return n.length>1?reduceToParents(n,e,r):n[0]}async function trickleStream(t,e,r){const n=new Root(r.layerRepeat);let o=0,s=1,u=n;for await(const l of itBatch(t,r.maxChildrenPerNode))u.isFull()&&(u!==n&&n.addChild(await u.reduce(e)),o&&o%r.layerRepeat==0&&s++,u=new SubTree(s,r.layerRepeat,o),o++),u.append(l);return u&&u!==n&&n.addChild(await u.reduce(e)),n.reduce(e)}class SubTree{constructor(e,r,n=0){this.maxDepth=e,this.layerRepeat=r,this.currentDepth=1,this.iteration=n,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:e,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;const e=this._findParent(this.node,this.currentDepth);return e?(this._addNextNodeToParent(e),!1):!0}_addNextNodeToParent(e){this.parent=e;const r={children:[],depth:e.depth+1,parent:e,maxDepth:this.maxDepth,maxChildren:Math.floor(e.children.length/this.layerRepeat)*this.layerRepeat};e.children.push(r),this.currentDepth=r.depth,this.node=r}append(e){this.node.data=e}reduce(e){return this._reduce(this.root,e)}async _reduce(e,r){let n=[];return e.children.length&&(n=await Promise.all(e.children.filter(o=>o.data).map(o=>this._reduce(o,r)))),r((e.data||[]).concat(n))}_findParent(e,r){const n=e.parent;if(!(!n||n.depth===0))return n.children.length===n.maxChildren||!n.maxChildren?this._findParent(n,r):n}}class Root extends SubTree{constructor(e){super(0,e);this.root.depth=0,this.currentDepth=1}addChild(e){this.root.children.push(e)}reduce(e){return e((this.root.data||[]).concat(this.root.children))}}async function*bufferImporter(t,e,r){for await(let n of t.content)yield async()=>{r.progress(n.length,t.path);let o;const s={codec:pb,cidVersion:r.cidVersion,hasher:r.hasher,onlyHash:r.onlyHash};return r.rawLeaves?(s.codec=raw$1,s.cidVersion=1):(o=new UnixFS({type:r.leafType,data:n,mtime:t.mtime,mode:t.mode}),n=encode$2({Data:o.marshal(),Links:[]})),{cid:await persist(n,e,s),unixfs:o,size:n.length}}}const dagBuilders={flat,balanced,trickle:trickleStream};async function*buildFileBatch(t,e,r){let n=-1,o,s;typeof r.bufferImporter=="function"?s=r.bufferImporter:s=bufferImporter;for await(const u of itParallelBatch(s(t,e,r),r.blockWriteConcurrency)){if(n++,n===0){o=u;continue}else n===1&&o&&(yield o,o=null);yield u}o&&(o.single=!0,yield o)}const reduce=(t,e,r)=>{async function n(o){if(o.length===1&&o[0].single&&r.reduceSingleLeafToSelf){const p=o[0];if(p.cid.code===code$2&&(t.mtime!==void 0||t.mode!==void 0)){let b=await e.get(p.cid);p.unixfs=new UnixFS({type:"file",mtime:t.mtime,mode:t.mode,data:b}),b=encode$2(prepare({Data:p.unixfs.marshal()})),p.cid=await persist(b,e,Z(M({},r),{codec:pb,hasher:r.hasher,cidVersion:r.cidVersion})),p.size=b.length}return{cid:p.cid,path:t.path,unixfs:p.unixfs,size:p.size}}const s=new UnixFS({type:"file",mtime:t.mtime,mode:t.mode}),u=o.filter(p=>p.cid.code===code$2&&p.size||p.unixfs&&!p.unixfs.data&&p.unixfs.fileSize()?!0:Boolean(p.unixfs&&p.unixfs.data&&p.unixfs.data.length)).map(p=>p.cid.code===code$2?(s.addBlockSize(p.size),{Name:"",Tsize:p.size,Hash:p.cid}):(!p.unixfs||!p.unixfs.data?s.addBlockSize(p.unixfs&&p.unixfs.fileSize()||0):s.addBlockSize(p.unixfs.data.length),{Name:"",Tsize:p.size,Hash:p.cid})),l={Data:s.marshal(),Links:u},h=encode$2(prepare(l));return{cid:await persist(h,e,r),path:t.path,unixfs:s,size:h.length+l.Links.reduce((p,b)=>p+b.Tsize,0)}}return n};function fileBuilder(t,e,r){const n=dagBuilders[r.strategy];if(!n)throw errCode$3(new Error(`Unknown importer build strategy name: ${r.strategy}`),"ERR_BAD_STRATEGY");return n(buildFileBatch(t,e,r),reduce(t,e,r),r)}var buffer={},base64Js={};base64Js.byteLength=byteLength;base64Js.toByteArray=toByteArray;base64Js.fromByteArray=fromByteArray;var lookup=[],revLookup=[],Arr=typeof Uint8Array!="undefined"?Uint8Array:Array,code$1="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var i$1=0,len=code$1.length;i$1<len;++i$1)lookup[i$1]=code$1[i$1],revLookup[code$1.charCodeAt(i$1)]=i$1;revLookup["-".charCodeAt(0)]=62;revLookup["_".charCodeAt(0)]=63;function getLens(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");r===-1&&(r=e);var n=r===e?0:4-r%4;return[r,n]}function byteLength(t){var e=getLens(t),r=e[0],n=e[1];return(r+n)*3/4-n}function _byteLength(t,e,r){return(e+r)*3/4-r}function toByteArray(t){var e,r=getLens(t),n=r[0],o=r[1],s=new Arr(_byteLength(t,n,o)),u=0,l=o>0?n-4:n,h;for(h=0;h<l;h+=4)e=revLookup[t.charCodeAt(h)]<<18|revLookup[t.charCodeAt(h+1)]<<12|revLookup[t.charCodeAt(h+2)]<<6|revLookup[t.charCodeAt(h+3)],s[u++]=e>>16&255,s[u++]=e>>8&255,s[u++]=e&255;return o===2&&(e=revLookup[t.charCodeAt(h)]<<2|revLookup[t.charCodeAt(h+1)]>>4,s[u++]=e&255),o===1&&(e=revLookup[t.charCodeAt(h)]<<10|revLookup[t.charCodeAt(h+1)]<<4|revLookup[t.charCodeAt(h+2)]>>2,s[u++]=e>>8&255,s[u++]=e&255),s}function tripletToBase64(t){return lookup[t>>18&63]+lookup[t>>12&63]+lookup[t>>6&63]+lookup[t&63]}function encodeChunk(t,e,r){for(var n,o=[],s=e;s<r;s+=3)n=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(t[s+2]&255),o.push(tripletToBase64(n));return o.join("")}function fromByteArray(t){for(var e,r=t.length,n=r%3,o=[],s=16383,u=0,l=r-n;u<l;u+=s)o.push(encodeChunk(t,u,u+s>l?l:u+s));return n===1?(e=t[r-1],o.push(lookup[e>>2]+lookup[e<<4&63]+"==")):n===2&&(e=(t[r-2]<<8)+t[r-1],o.push(lookup[e>>10]+lookup[e>>4&63]+lookup[e<<2&63]+"=")),o.join("")}var ieee754={};/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ieee754.read=function(t,e,r,n,o){var s,u,l=o*8-n-1,h=(1<<l)-1,d=h>>1,p=-7,b=r?o-1:0,_=r?-1:1,T=t[e+b];for(b+=_,s=T&(1<<-p)-1,T>>=-p,p+=l;p>0;s=s*256+t[e+b],b+=_,p-=8);for(u=s&(1<<-p)-1,s>>=-p,p+=n;p>0;u=u*256+t[e+b],b+=_,p-=8);if(s===0)s=1-d;else{if(s===h)return u?NaN:(T?-1:1)*(1/0);u=u+Math.pow(2,n),s=s-d}return(T?-1:1)*u*Math.pow(2,s-n)};ieee754.write=function(t,e,r,n,o,s){var u,l,h,d=s*8-o-1,p=(1<<d)-1,b=p>>1,_=o===23?Math.pow(2,-24)-Math.pow(2,-77):0,T=n?0:s-1,C=n?1:-1,g=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(l=isNaN(e)?1:0,u=p):(u=Math.floor(Math.log(e)/Math.LN2),e*(h=Math.pow(2,-u))<1&&(u--,h*=2),u+b>=1?e+=_/h:e+=_*Math.pow(2,1-b),e*h>=2&&(u++,h/=2),u+b>=p?(l=0,u=p):u+b>=1?(l=(e*h-1)*Math.pow(2,o),u=u+b):(l=e*Math.pow(2,b-1)*Math.pow(2,o),u=0));o>=8;t[r+T]=l&255,T+=C,l/=256,o-=8);for(u=u<<o|l,d+=o;d>0;t[r+T]=u&255,T+=C,u/=256,d-=8);t[r+T-C]|=g*128};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(t){const e=base64Js,r=ieee754,n=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;t.Buffer=l,t.SlowBuffer=R,t.INSPECT_MAX_BYTES=50;const o=2147483647;t.kMaxLength=o,l.TYPED_ARRAY_SUPPORT=s(),!l.TYPED_ARRAY_SUPPORT&&typeof console!="undefined"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function s(){try{const f=new Uint8Array(1),a={foo:function(){return 42}};return Object.setPrototypeOf(a,Uint8Array.prototype),Object.setPrototypeOf(f,a),f.foo()===42}catch{return!1}}Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(!!l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(!!l.isBuffer(this))return this.byteOffset}});function u(f){if(f>o)throw new RangeError('The value "'+f+'" is invalid for option "size"');const a=new Uint8Array(f);return Object.setPrototypeOf(a,l.prototype),a}function l(f,a,c){if(typeof f=="number"){if(typeof a=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return b(f)}return h(f,a,c)}l.poolSize=8192;function h(f,a,c){if(typeof f=="string")return _(f,a);if(ArrayBuffer.isView(f))return C(f);if(f==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof f);if(q(f,ArrayBuffer)||f&&q(f.buffer,ArrayBuffer)||typeof SharedArrayBuffer!="undefined"&&(q(f,SharedArrayBuffer)||f&&q(f.buffer,SharedArrayBuffer)))return g(f,a,c);if(typeof f=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const y=f.valueOf&&f.valueOf();if(y!=null&&y!==f)return l.from(y,a,c);const m=B(f);if(m)return m;if(typeof Symbol!="undefined"&&Symbol.toPrimitive!=null&&typeof f[Symbol.toPrimitive]=="function")return l.from(f[Symbol.toPrimitive]("string"),a,c);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof f)}l.from=function(f,a,c){return h(f,a,c)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array);function d(f){if(typeof f!="number")throw new TypeError('"size" argument must be of type number');if(f<0)throw new RangeError('The value "'+f+'" is invalid for option "size"')}function p(f,a,c){return d(f),f<=0?u(f):a!==void 0?typeof c=="string"?u(f).fill(a,c):u(f).fill(a):u(f)}l.alloc=function(f,a,c){return p(f,a,c)};function b(f){return d(f),u(f<0?0:k(f)|0)}l.allocUnsafe=function(f){return b(f)},l.allocUnsafeSlow=function(f){return b(f)};function _(f,a){if((typeof a!="string"||a==="")&&(a="utf8"),!l.isEncoding(a))throw new TypeError("Unknown encoding: "+a);const c=x(f,a)|0;let y=u(c);const m=y.write(f,a);return m!==c&&(y=y.slice(0,m)),y}function T(f){const a=f.length<0?0:k(f.length)|0,c=u(a);for(let y=0;y<a;y+=1)c[y]=f[y]&255;return c}function C(f){if(q(f,Uint8Array)){const a=new Uint8Array(f);return g(a.buffer,a.byteOffset,a.byteLength)}return T(f)}function g(f,a,c){if(a<0||f.byteLength<a)throw new RangeError('"offset" is outside of buffer bounds');if(f.byteLength<a+(c||0))throw new RangeError('"length" is outside of buffer bounds');let y;return a===void 0&&c===void 0?y=new Uint8Array(f):c===void 0?y=new Uint8Array(f,a):y=new Uint8Array(f,a,c),Object.setPrototypeOf(y,l.prototype),y}function B(f){if(l.isBuffer(f)){const a=k(f.length)|0,c=u(a);return c.length===0||f.copy(c,0,0,a),c}if(f.length!==void 0)return typeof f.length!="number"||ne(f.length)?u(0):T(f);if(f.type==="Buffer"&&Array.isArray(f.data))return T(f.data)}function k(f){if(f>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return f|0}function R(f){return+f!=f&&(f=0),l.alloc(+f)}l.isBuffer=function(a){return a!=null&&a._isBuffer===!0&&a!==l.prototype},l.compare=function(a,c){if(q(a,Uint8Array)&&(a=l.from(a,a.offset,a.byteLength)),q(c,Uint8Array)&&(c=l.from(c,c.offset,c.byteLength)),!l.isBuffer(a)||!l.isBuffer(c))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(a===c)return 0;let y=a.length,m=c.length;for(let w=0,$=Math.min(y,m);w<$;++w)if(a[w]!==c[w]){y=a[w],m=c[w];break}return y<m?-1:m<y?1:0},l.isEncoding=function(a){switch(String(a).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(a,c){if(!Array.isArray(a))throw new TypeError('"list" argument must be an Array of Buffers');if(a.length===0)return l.alloc(0);let y;if(c===void 0)for(c=0,y=0;y<a.length;++y)c+=a[y].length;const m=l.allocUnsafe(c);let w=0;for(y=0;y<a.length;++y){let $=a[y];if(q($,Uint8Array))w+$.length>m.length?(l.isBuffer($)||($=l.from($)),$.copy(m,w)):Uint8Array.prototype.set.call(m,$,w);else if(l.isBuffer($))$.copy(m,w);else throw new TypeError('"list" argument must be an Array of Buffers');w+=$.length}return m};function x(f,a){if(l.isBuffer(f))return f.length;if(ArrayBuffer.isView(f)||q(f,ArrayBuffer))return f.byteLength;if(typeof f!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof f);const c=f.length,y=arguments.length>2&&arguments[2]===!0;if(!y&&c===0)return 0;let m=!1;for(;;)switch(a){case"ascii":case"latin1":case"binary":return c;case"utf8":case"utf-8":return re(f).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return c*2;case"hex":return c>>>1;case"base64":return fe(f).length;default:if(m)return y?-1:re(f).length;a=(""+a).toLowerCase(),m=!0}}l.byteLength=x;function v(f,a,c){let y=!1;if((a===void 0||a<0)&&(a=0),a>this.length||((c===void 0||c>this.length)&&(c=this.length),c<=0)||(c>>>=0,a>>>=0,c<=a))return"";for(f||(f="utf8");;)switch(f){case"hex":return me(this,a,c);case"utf8":case"utf-8":return W(this,a,c);case"ascii":return ye(this,a,c);case"latin1":case"binary":return ge(this,a,c);case"base64":return Y(this,a,c);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return we(this,a,c);default:if(y)throw new TypeError("Unknown encoding: "+f);f=(f+"").toLowerCase(),y=!0}}l.prototype._isBuffer=!0;function E(f,a,c){const y=f[a];f[a]=f[c],f[c]=y}l.prototype.swap16=function(){const a=this.length;if(a%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let c=0;c<a;c+=2)E(this,c,c+1);return this},l.prototype.swap32=function(){const a=this.length;if(a%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let c=0;c<a;c+=4)E(this,c,c+3),E(this,c+1,c+2);return this},l.prototype.swap64=function(){const a=this.length;if(a%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let c=0;c<a;c+=8)E(this,c,c+7),E(this,c+1,c+6),E(this,c+2,c+5),E(this,c+3,c+4);return this},l.prototype.toString=function(){const a=this.length;return a===0?"":arguments.length===0?W(this,0,a):v.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(a){if(!l.isBuffer(a))throw new TypeError("Argument must be a Buffer");return this===a?!0:l.compare(this,a)===0},l.prototype.inspect=function(){let a="";const c=t.INSPECT_MAX_BYTES;return a=this.toString("hex",0,c).replace(/(.{2})/g,"$1 ").trim(),this.length>c&&(a+=" ... "),"<Buffer "+a+">"},n&&(l.prototype[n]=l.prototype.inspect),l.prototype.compare=function(a,c,y,m,w){if(q(a,Uint8Array)&&(a=l.from(a,a.offset,a.byteLength)),!l.isBuffer(a))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof a);if(c===void 0&&(c=0),y===void 0&&(y=a?a.length:0),m===void 0&&(m=0),w===void 0&&(w=this.length),c<0||y>a.length||m<0||w>this.length)throw new RangeError("out of range index");if(m>=w&&c>=y)return 0;if(m>=w)return-1;if(c>=y)return 1;if(c>>>=0,y>>>=0,m>>>=0,w>>>=0,this===a)return 0;let $=w-m,O=y-c;const P=Math.min($,O),L=this.slice(m,w),j=a.slice(c,y);for(let U=0;U<P;++U)if(L[U]!==j[U]){$=L[U],O=j[U];break}return $<O?-1:O<$?1:0};function A(f,a,c,y,m){if(f.length===0)return-1;if(typeof c=="string"?(y=c,c=0):c>2147483647?c=2147483647:c<-2147483648&&(c=-2147483648),c=+c,ne(c)&&(c=m?0:f.length-1),c<0&&(c=f.length+c),c>=f.length){if(m)return-1;c=f.length-1}else if(c<0)if(m)c=0;else return-1;if(typeof a=="string"&&(a=l.from(a,y)),l.isBuffer(a))return a.length===0?-1:S(f,a,c,y,m);if(typeof a=="number")return a=a&255,typeof Uint8Array.prototype.indexOf=="function"?m?Uint8Array.prototype.indexOf.call(f,a,c):Uint8Array.prototype.lastIndexOf.call(f,a,c):S(f,[a],c,y,m);throw new TypeError("val must be string, number or Buffer")}function S(f,a,c,y,m){let w=1,$=f.length,O=a.length;if(y!==void 0&&(y=String(y).toLowerCase(),y==="ucs2"||y==="ucs-2"||y==="utf16le"||y==="utf-16le")){if(f.length<2||a.length<2)return-1;w=2,$/=2,O/=2,c/=2}function P(j,U){return w===1?j[U]:j.readUInt16BE(U*w)}let L;if(m){let j=-1;for(L=c;L<$;L++)if(P(f,L)===P(a,j===-1?0:L-j)){if(j===-1&&(j=L),L-j+1===O)return j*w}else j!==-1&&(L-=L-j),j=-1}else for(c+O>$&&(c=$-O),L=c;L>=0;L--){let j=!0;for(let U=0;U<O;U++)if(P(f,L+U)!==P(a,U)){j=!1;break}if(j)return L}return-1}l.prototype.includes=function(a,c,y){return this.indexOf(a,c,y)!==-1},l.prototype.indexOf=function(a,c,y){return A(this,a,c,y,!0)},l.prototype.lastIndexOf=function(a,c,y){return A(this,a,c,y,!1)};function D(f,a,c,y){c=Number(c)||0;const m=f.length-c;y?(y=Number(y),y>m&&(y=m)):y=m;const w=a.length;y>w/2&&(y=w/2);let $;for($=0;$<y;++$){const O=parseInt(a.substr($*2,2),16);if(ne(O))return $;f[c+$]=O}return $}function I(f,a,c,y){return ee(re(a,f.length-c),f,c,y)}function F(f,a,c,y){return ee(Be(a),f,c,y)}function V(f,a,c,y){return ee(fe(a),f,c,y)}function G(f,a,c,y){return ee($e(a,f.length-c),f,c,y)}l.prototype.write=function(a,c,y,m){if(c===void 0)m="utf8",y=this.length,c=0;else if(y===void 0&&typeof c=="string")m=c,y=this.length,c=0;else if(isFinite(c))c=c>>>0,isFinite(y)?(y=y>>>0,m===void 0&&(m="utf8")):(m=y,y=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const w=this.length-c;if((y===void 0||y>w)&&(y=w),a.length>0&&(y<0||c<0)||c>this.length)throw new RangeError("Attempt to write outside buffer bounds");m||(m="utf8");let $=!1;for(;;)switch(m){case"hex":return D(this,a,c,y);case"utf8":case"utf-8":return I(this,a,c,y);case"ascii":case"latin1":case"binary":return F(this,a,c,y);case"base64":return V(this,a,c,y);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return G(this,a,c,y);default:if($)throw new TypeError("Unknown encoding: "+m);m=(""+m).toLowerCase(),$=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Y(f,a,c){return a===0&&c===f.length?e.fromByteArray(f):e.fromByteArray(f.slice(a,c))}function W(f,a,c){c=Math.min(f.length,c);const y=[];let m=a;for(;m<c;){const w=f[m];let $=null,O=w>239?4:w>223?3:w>191?2:1;if(m+O<=c){let P,L,j,U;switch(O){case 1:w<128&&($=w);break;case 2:P=f[m+1],(P&192)==128&&(U=(w&31)<<6|P&63,U>127&&($=U));break;case 3:P=f[m+1],L=f[m+2],(P&192)==128&&(L&192)==128&&(U=(w&15)<<12|(P&63)<<6|L&63,U>2047&&(U<55296||U>57343)&&($=U));break;case 4:P=f[m+1],L=f[m+2],j=f[m+3],(P&192)==128&&(L&192)==128&&(j&192)==128&&(U=(w&15)<<18|(P&63)<<12|(L&63)<<6|j&63,U>65535&&U<1114112&&($=U))}}$===null?($=65533,O=1):$>65535&&($-=65536,y.push($>>>10&1023|55296),$=56320|$&1023),y.push($),m+=O}return pe(y)}const N=4096;function pe(f){const a=f.length;if(a<=N)return String.fromCharCode.apply(String,f);let c="",y=0;for(;y<a;)c+=String.fromCharCode.apply(String,f.slice(y,y+=N));return c}function ye(f,a,c){let y="";c=Math.min(f.length,c);for(let m=a;m<c;++m)y+=String.fromCharCode(f[m]&127);return y}function ge(f,a,c){let y="";c=Math.min(f.length,c);for(let m=a;m<c;++m)y+=String.fromCharCode(f[m]);return y}function me(f,a,c){const y=f.length;(!a||a<0)&&(a=0),(!c||c<0||c>y)&&(c=y);let m="";for(let w=a;w<c;++w)m+=Te[f[w]];return m}function we(f,a,c){const y=f.slice(a,c);let m="";for(let w=0;w<y.length-1;w+=2)m+=String.fromCharCode(y[w]+y[w+1]*256);return m}l.prototype.slice=function(a,c){const y=this.length;a=~~a,c=c===void 0?y:~~c,a<0?(a+=y,a<0&&(a=0)):a>y&&(a=y),c<0?(c+=y,c<0&&(c=0)):c>y&&(c=y),c<a&&(c=a);const m=this.subarray(a,c);return Object.setPrototypeOf(m,l.prototype),m};function z(f,a,c){if(f%1!=0||f<0)throw new RangeError("offset is not uint");if(f+a>c)throw new RangeError("Trying to access beyond buffer length")}l.prototype.readUintLE=l.prototype.readUIntLE=function(a,c,y){a=a>>>0,c=c>>>0,y||z(a,c,this.length);let m=this[a],w=1,$=0;for(;++$<c&&(w*=256);)m+=this[a+$]*w;return m},l.prototype.readUintBE=l.prototype.readUIntBE=function(a,c,y){a=a>>>0,c=c>>>0,y||z(a,c,this.length);let m=this[a+--c],w=1;for(;c>0&&(w*=256);)m+=this[a+--c]*w;return m},l.prototype.readUint8=l.prototype.readUInt8=function(a,c){return a=a>>>0,c||z(a,1,this.length),this[a]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(a,c){return a=a>>>0,c||z(a,2,this.length),this[a]|this[a+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(a,c){return a=a>>>0,c||z(a,2,this.length),this[a]<<8|this[a+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(a,c){return a=a>>>0,c||z(a,4,this.length),(this[a]|this[a+1]<<8|this[a+2]<<16)+this[a+3]*16777216},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(a,c){return a=a>>>0,c||z(a,4,this.length),this[a]*16777216+(this[a+1]<<16|this[a+2]<<8|this[a+3])},l.prototype.readBigUInt64LE=K(function(a){a=a>>>0,J(a,"offset");const c=this[a],y=this[a+7];(c===void 0||y===void 0)&&Q(a,this.length-8);const m=c+this[++a]*2**8+this[++a]*2**16+this[++a]*2**24,w=this[++a]+this[++a]*2**8+this[++a]*2**16+y*2**24;return BigInt(m)+(BigInt(w)<<BigInt(32))}),l.prototype.readBigUInt64BE=K(function(a){a=a>>>0,J(a,"offset");const c=this[a],y=this[a+7];(c===void 0||y===void 0)&&Q(a,this.length-8);const m=c*2**24+this[++a]*2**16+this[++a]*2**8+this[++a],w=this[++a]*2**24+this[++a]*2**16+this[++a]*2**8+y;return(BigInt(m)<<BigInt(32))+BigInt(w)}),l.prototype.readIntLE=function(a,c,y){a=a>>>0,c=c>>>0,y||z(a,c,this.length);let m=this[a],w=1,$=0;for(;++$<c&&(w*=256);)m+=this[a+$]*w;return w*=128,m>=w&&(m-=Math.pow(2,8*c)),m},l.prototype.readIntBE=function(a,c,y){a=a>>>0,c=c>>>0,y||z(a,c,this.length);let m=c,w=1,$=this[a+--m];for(;m>0&&(w*=256);)$+=this[a+--m]*w;return w*=128,$>=w&&($-=Math.pow(2,8*c)),$},l.prototype.readInt8=function(a,c){return a=a>>>0,c||z(a,1,this.length),this[a]&128?(255-this[a]+1)*-1:this[a]},l.prototype.readInt16LE=function(a,c){a=a>>>0,c||z(a,2,this.length);const y=this[a]|this[a+1]<<8;return y&32768?y|4294901760:y},l.prototype.readInt16BE=function(a,c){a=a>>>0,c||z(a,2,this.length);const y=this[a+1]|this[a]<<8;return y&32768?y|4294901760:y},l.prototype.readInt32LE=function(a,c){return a=a>>>0,c||z(a,4,this.length),this[a]|this[a+1]<<8|this[a+2]<<16|this[a+3]<<24},l.prototype.readInt32BE=function(a,c){return a=a>>>0,c||z(a,4,this.length),this[a]<<24|this[a+1]<<16|this[a+2]<<8|this[a+3]},l.prototype.readBigInt64LE=K(function(a){a=a>>>0,J(a,"offset");const c=this[a],y=this[a+7];(c===void 0||y===void 0)&&Q(a,this.length-8);const m=this[a+4]+this[a+5]*2**8+this[a+6]*2**16+(y<<24);return(BigInt(m)<<BigInt(32))+BigInt(c+this[++a]*2**8+this[++a]*2**16+this[++a]*2**24)}),l.prototype.readBigInt64BE=K(function(a){a=a>>>0,J(a,"offset");const c=this[a],y=this[a+7];(c===void 0||y===void 0)&&Q(a,this.length-8);const m=(c<<24)+this[++a]*2**16+this[++a]*2**8+this[++a];return(BigInt(m)<<BigInt(32))+BigInt(this[++a]*2**24+this[++a]*2**16+this[++a]*2**8+y)}),l.prototype.readFloatLE=function(a,c){return a=a>>>0,c||z(a,4,this.length),r.read(this,a,!0,23,4)},l.prototype.readFloatBE=function(a,c){return a=a>>>0,c||z(a,4,this.length),r.read(this,a,!1,23,4)},l.prototype.readDoubleLE=function(a,c){return a=a>>>0,c||z(a,8,this.length),r.read(this,a,!0,52,8)},l.prototype.readDoubleBE=function(a,c){return a=a>>>0,c||z(a,8,this.length),r.read(this,a,!1,52,8)};function H(f,a,c,y,m,w){if(!l.isBuffer(f))throw new TypeError('"buffer" argument must be a Buffer instance');if(a>m||a<w)throw new RangeError('"value" argument is out of bounds');if(c+y>f.length)throw new RangeError("Index out of range")}l.prototype.writeUintLE=l.prototype.writeUIntLE=function(a,c,y,m){if(a=+a,c=c>>>0,y=y>>>0,!m){const O=Math.pow(2,8*y)-1;H(this,a,c,y,O,0)}let w=1,$=0;for(this[c]=a&255;++$<y&&(w*=256);)this[c+$]=a/w&255;return c+y},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(a,c,y,m){if(a=+a,c=c>>>0,y=y>>>0,!m){const O=Math.pow(2,8*y)-1;H(this,a,c,y,O,0)}let w=y-1,$=1;for(this[c+w]=a&255;--w>=0&&($*=256);)this[c+w]=a/$&255;return c+y},l.prototype.writeUint8=l.prototype.writeUInt8=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,1,255,0),this[c]=a&255,c+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,2,65535,0),this[c]=a&255,this[c+1]=a>>>8,c+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,2,65535,0),this[c]=a>>>8,this[c+1]=a&255,c+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,4,4294967295,0),this[c+3]=a>>>24,this[c+2]=a>>>16,this[c+1]=a>>>8,this[c]=a&255,c+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,4,4294967295,0),this[c]=a>>>24,this[c+1]=a>>>16,this[c+2]=a>>>8,this[c+3]=a&255,c+4};function ie(f,a,c,y,m){le(a,y,m,f,c,7);let w=Number(a&BigInt(4294967295));f[c++]=w,w=w>>8,f[c++]=w,w=w>>8,f[c++]=w,w=w>>8,f[c++]=w;let $=Number(a>>BigInt(32)&BigInt(4294967295));return f[c++]=$,$=$>>8,f[c++]=$,$=$>>8,f[c++]=$,$=$>>8,f[c++]=$,c}function oe(f,a,c,y,m){le(a,y,m,f,c,7);let w=Number(a&BigInt(4294967295));f[c+7]=w,w=w>>8,f[c+6]=w,w=w>>8,f[c+5]=w,w=w>>8,f[c+4]=w;let $=Number(a>>BigInt(32)&BigInt(4294967295));return f[c+3]=$,$=$>>8,f[c+2]=$,$=$>>8,f[c+1]=$,$=$>>8,f[c]=$,c+8}l.prototype.writeBigUInt64LE=K(function(a,c=0){return ie(this,a,c,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeBigUInt64BE=K(function(a,c=0){return oe(this,a,c,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeIntLE=function(a,c,y,m){if(a=+a,c=c>>>0,!m){const P=Math.pow(2,8*y-1);H(this,a,c,y,P-1,-P)}let w=0,$=1,O=0;for(this[c]=a&255;++w<y&&($*=256);)a<0&&O===0&&this[c+w-1]!==0&&(O=1),this[c+w]=(a/$>>0)-O&255;return c+y},l.prototype.writeIntBE=function(a,c,y,m){if(a=+a,c=c>>>0,!m){const P=Math.pow(2,8*y-1);H(this,a,c,y,P-1,-P)}let w=y-1,$=1,O=0;for(this[c+w]=a&255;--w>=0&&($*=256);)a<0&&O===0&&this[c+w+1]!==0&&(O=1),this[c+w]=(a/$>>0)-O&255;return c+y},l.prototype.writeInt8=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,1,127,-128),a<0&&(a=255+a+1),this[c]=a&255,c+1},l.prototype.writeInt16LE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,2,32767,-32768),this[c]=a&255,this[c+1]=a>>>8,c+2},l.prototype.writeInt16BE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,2,32767,-32768),this[c]=a>>>8,this[c+1]=a&255,c+2},l.prototype.writeInt32LE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,4,2147483647,-2147483648),this[c]=a&255,this[c+1]=a>>>8,this[c+2]=a>>>16,this[c+3]=a>>>24,c+4},l.prototype.writeInt32BE=function(a,c,y){return a=+a,c=c>>>0,y||H(this,a,c,4,2147483647,-2147483648),a<0&&(a=4294967295+a+1),this[c]=a>>>24,this[c+1]=a>>>16,this[c+2]=a>>>8,this[c+3]=a&255,c+4},l.prototype.writeBigInt64LE=K(function(a,c=0){return ie(this,a,c,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeBigInt64BE=K(function(a,c=0){return oe(this,a,c,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function se(f,a,c,y,m,w){if(c+y>f.length)throw new RangeError("Index out of range");if(c<0)throw new RangeError("Index out of range")}function ae(f,a,c,y,m){return a=+a,c=c>>>0,m||se(f,a,c,4),r.write(f,a,c,y,23,4),c+4}l.prototype.writeFloatLE=function(a,c,y){return ae(this,a,c,!0,y)},l.prototype.writeFloatBE=function(a,c,y){return ae(this,a,c,!1,y)};function ce(f,a,c,y,m){return a=+a,c=c>>>0,m||se(f,a,c,8),r.write(f,a,c,y,52,8),c+8}l.prototype.writeDoubleLE=function(a,c,y){return ce(this,a,c,!0,y)},l.prototype.writeDoubleBE=function(a,c,y){return ce(this,a,c,!1,y)},l.prototype.copy=function(a,c,y,m){if(!l.isBuffer(a))throw new TypeError("argument should be a Buffer");if(y||(y=0),!m&&m!==0&&(m=this.length),c>=a.length&&(c=a.length),c||(c=0),m>0&&m<y&&(m=y),m===y||a.length===0||this.length===0)return 0;if(c<0)throw new RangeError("targetStart out of bounds");if(y<0||y>=this.length)throw new RangeError("Index out of range");if(m<0)throw new RangeError("sourceEnd out of bounds");m>this.length&&(m=this.length),a.length-c<m-y&&(m=a.length-c+y);const w=m-y;return this===a&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(c,y,m):Uint8Array.prototype.set.call(a,this.subarray(y,m),c),w},l.prototype.fill=function(a,c,y,m){if(typeof a=="string"){if(typeof c=="string"?(m=c,c=0,y=this.length):typeof y=="string"&&(m=y,y=this.length),m!==void 0&&typeof m!="string")throw new TypeError("encoding must be a string");if(typeof m=="string"&&!l.isEncoding(m))throw new TypeError("Unknown encoding: "+m);if(a.length===1){const $=a.charCodeAt(0);(m==="utf8"&&$<128||m==="latin1")&&(a=$)}}else typeof a=="number"?a=a&255:typeof a=="boolean"&&(a=Number(a));if(c<0||this.length<c||this.length<y)throw new RangeError("Out of range index");if(y<=c)return this;c=c>>>0,y=y===void 0?this.length:y>>>0,a||(a=0);let w;if(typeof a=="number")for(w=c;w<y;++w)this[w]=a;else{const $=l.isBuffer(a)?a:l.from(a,m),O=$.length;if(O===0)throw new TypeError('The value "'+a+'" is invalid for argument "value"');for(w=0;w<y-c;++w)this[w+c]=$[w%O]}return this};const X={};function te(f,a,c){X[f]=class extends c{constructor(){super();Object.defineProperty(this,"message",{value:a.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${f}]`,this.stack,delete this.name}get code(){return f}set code(m){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:m,writable:!0})}toString(){return`${this.name} [${f}]: ${this.message}`}}}te("ERR_BUFFER_OUT_OF_BOUNDS",function(f){return f?`${f} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),te("ERR_INVALID_ARG_TYPE",function(f,a){return`The "${f}" argument must be of type number. Received type ${typeof a}`},TypeError),te("ERR_OUT_OF_RANGE",function(f,a,c){let y=`The value of "${f}" is out of range.`,m=c;return Number.isInteger(c)&&Math.abs(c)>2**32?m=ue(String(c)):typeof c=="bigint"&&(m=String(c),(c>BigInt(2)**BigInt(32)||c<-(BigInt(2)**BigInt(32)))&&(m=ue(m)),m+="n"),y+=` It must be ${a}. Received ${m}`,y},RangeError);function ue(f){let a="",c=f.length;const y=f[0]==="-"?1:0;for(;c>=y+4;c-=3)a=`_${f.slice(c-3,c)}${a}`;return`${f.slice(0,c)}${a}`}function be(f,a,c){J(a,"offset"),(f[a]===void 0||f[a+c]===void 0)&&Q(a,f.length-(c+1))}function le(f,a,c,y,m,w){if(f>c||f<a){const $=typeof a=="bigint"?"n":"";let O;throw w>3?a===0||a===BigInt(0)?O=`>= 0${$} and < 2${$} ** ${(w+1)*8}${$}`:O=`>= -(2${$} ** ${(w+1)*8-1}${$}) and < 2 ** ${(w+1)*8-1}${$}`:O=`>= ${a}${$} and <= ${c}${$}`,new X.ERR_OUT_OF_RANGE("value",O,f)}be(y,m,w)}function J(f,a){if(typeof f!="number")throw new X.ERR_INVALID_ARG_TYPE(a,"number",f)}function Q(f,a,c){throw Math.floor(f)!==f?(J(f,c),new X.ERR_OUT_OF_RANGE(c||"offset","an integer",f)):a<0?new X.ERR_BUFFER_OUT_OF_BOUNDS:new X.ERR_OUT_OF_RANGE(c||"offset",`>= ${c?1:0} and <= ${a}`,f)}const _e=/[^+/0-9A-Za-z-_]/g;function Ee(f){if(f=f.split("=")[0],f=f.trim().replace(_e,""),f.length<2)return"";for(;f.length%4!=0;)f=f+"=";return f}function re(f,a){a=a||1/0;let c;const y=f.length;let m=null;const w=[];for(let $=0;$<y;++$){if(c=f.charCodeAt($),c>55295&&c<57344){if(!m){if(c>56319){(a-=3)>-1&&w.push(239,191,189);continue}else if($+1===y){(a-=3)>-1&&w.push(239,191,189);continue}m=c;continue}if(c<56320){(a-=3)>-1&&w.push(239,191,189),m=c;continue}c=(m-55296<<10|c-56320)+65536}else m&&(a-=3)>-1&&w.push(239,191,189);if(m=null,c<128){if((a-=1)<0)break;w.push(c)}else if(c<2048){if((a-=2)<0)break;w.push(c>>6|192,c&63|128)}else if(c<65536){if((a-=3)<0)break;w.push(c>>12|224,c>>6&63|128,c&63|128)}else if(c<1114112){if((a-=4)<0)break;w.push(c>>18|240,c>>12&63|128,c>>6&63|128,c&63|128)}else throw new Error("Invalid code point")}return w}function Be(f){const a=[];for(let c=0;c<f.length;++c)a.push(f.charCodeAt(c)&255);return a}function $e(f,a){let c,y,m;const w=[];for(let $=0;$<f.length&&!((a-=2)<0);++$)c=f.charCodeAt($),y=c>>8,m=c%256,w.push(m),w.push(y);return w}function fe(f){return e.toByteArray(Ee(f))}function ee(f,a,c,y){let m;for(m=0;m<y&&!(m+c>=a.length||m>=f.length);++m)a[m+c]=f[m];return m}function q(f,a){return f instanceof a||f!=null&&f.constructor!=null&&f.constructor.name!=null&&f.constructor.name===a.name}function ne(f){return f!==f}const Te=function(){const f="0123456789abcdef",a=new Array(256);for(let c=0;c<16;++c){const y=c*16;for(let m=0;m<16;++m)a[y+m]=f[c]+f[m]}return a}();function K(f){return typeof BigInt=="undefined"?Ae:f}function Ae(){throw new Error("BigInt not supported")}})(buffer);const{Buffer}=buffer,symbol=Symbol.for("BufferList");function BufferList(t){if(!(this instanceof BufferList))return new BufferList(t);BufferList._init.call(this,t)}BufferList._init=function t(e){Object.defineProperty(this,symbol,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e)};BufferList.prototype._new=function t(e){return new BufferList(e)};BufferList.prototype._offset=function t(e){if(e===0)return[0,0];let r=0;for(let n=0;n<this._bufs.length;n++){const o=r+this._bufs[n].length;if(e<o||n===this._bufs.length-1)return[n,e-r];r=o}};BufferList.prototype._reverseOffset=function(t){const e=t[0];let r=t[1];for(let n=0;n<e;n++)r+=this._bufs[n].length;return r};BufferList.prototype.get=function t(e){if(e>this.length||e<0)return;const r=this._offset(e);return this._bufs[r[0]][r[1]]};BufferList.prototype.slice=function t(e,r){return typeof e=="number"&&e<0&&(e+=this.length),typeof r=="number"&&r<0&&(r+=this.length),this.copy(null,0,e,r)};BufferList.prototype.copy=function t(e,r,n,o){if((typeof n!="number"||n<0)&&(n=0),(typeof o!="number"||o>this.length)&&(o=this.length),n>=this.length||o<=0)return e||Buffer.alloc(0);const s=!!e,u=this._offset(n),l=o-n;let h=l,d=s&&r||0,p=u[1];if(n===0&&o===this.length){if(!s)return this._bufs.length===1?this._bufs[0]:Buffer.concat(this._bufs,this.length);for(let b=0;b<this._bufs.length;b++)this._bufs[b].copy(e,d),d+=this._bufs[b].length;return e}if(h<=this._bufs[u[0]].length-p)return s?this._bufs[u[0]].copy(e,r,p,p+h):this._bufs[u[0]].slice(p,p+h);s||(e=Buffer.allocUnsafe(l));for(let b=u[0];b<this._bufs.length;b++){const _=this._bufs[b].length-p;if(h>_)this._bufs[b].copy(e,d,p),d+=_;else{this._bufs[b].copy(e,d,p,p+h),d+=_;break}h-=_,p&&(p=0)}return e.length>d?e.slice(0,d):e};BufferList.prototype.shallowSlice=function t(e,r){if(e=e||0,r=typeof r!="number"?this.length:r,e<0&&(e+=this.length),r<0&&(r+=this.length),e===r)return this._new();const n=this._offset(e),o=this._offset(r),s=this._bufs.slice(n[0],o[0]+1);return o[1]===0?s.pop():s[s.length-1]=s[s.length-1].slice(0,o[1]),n[1]!==0&&(s[0]=s[0].slice(n[1])),this._new(s)};BufferList.prototype.toString=function t(e,r,n){return this.slice(r,n).toString(e)};BufferList.prototype.consume=function t(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;for(;this._bufs.length;)if(e>=this._bufs[0].length)e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else{this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}return this};BufferList.prototype.duplicate=function t(){const e=this._new();for(let r=0;r<this._bufs.length;r++)e.append(this._bufs[r]);return e};BufferList.prototype.append=function t(e){if(e==null)return this;if(e.buffer)this._appendBuffer(Buffer.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let r=0;r<e.length;r++)this.append(e[r]);else if(this._isBufferList(e))for(let r=0;r<e._bufs.length;r++)this.append(e._bufs[r]);else typeof e=="number"&&(e=e.toString()),this._appendBuffer(Buffer.from(e));return this};BufferList.prototype._appendBuffer=function t(e){this._bufs.push(e),this.length+=e.length};BufferList.prototype.indexOf=function(t,e,r){if(r===void 0&&typeof e=="string"&&(r=e,e=void 0),typeof t=="function"||Array.isArray(t))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof t=="number"?t=Buffer.from([t]):typeof t=="string"?t=Buffer.from(t,r):this._isBufferList(t)?t=t.slice():Array.isArray(t.buffer)?t=Buffer.from(t.buffer,t.byteOffset,t.byteLength):Buffer.isBuffer(t)||(t=Buffer.from(t)),e=Number(e||0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const n=this._offset(e);let o=n[0],s=n[1];for(;o<this._bufs.length;o++){const u=this._bufs[o];for(;s<u.length;)if(u.length-s>=t.length){const h=u.indexOf(t,s);if(h!==-1)return this._reverseOffset([o,h]);s=u.length-t.length+1}else{const h=this._reverseOffset([o,s]);if(this._match(h,t))return h;s++}s=0}return-1};BufferList.prototype._match=function(t,e){if(this.length-t<e.length)return!1;for(let r=0;r<e.length;r++)if(this.get(t+r)!==e[r])return!1;return!0};(function(){const t={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const e in t)(function(r){t[r]===null?BufferList.prototype[r]=function(n,o){return this.slice(n,n+o)[r](0,o)}:BufferList.prototype[r]=function(n=0){return this.slice(n,n+t[r])[r](0)}})(e)})();BufferList.prototype._isBufferList=function t(e){return e instanceof BufferList||BufferList.isBufferList(e)};BufferList.isBufferList=function t(e){return e!=null&&e[symbol]};var BufferList_1=BufferList;class Rabin$1{constructor(e,r=12,n=8*1024,o=32*1024,s=64,u){this.bits=r,this.min=n,this.max=o,this.asModule=e,this.rabin=new e.Rabin(r,n,o,s,u),this.polynomial=u}fingerprint(e){const{__retain:r,__release:n,__allocArray:o,__getInt32Array:s,Int32Array_ID:u,Uint8Array_ID:l}=this.asModule,h=new Int32Array(Math.ceil(e.length/this.min)),d=r(o(u,h)),p=r(o(l,e)),b=this.rabin.fingerprint(p,d),_=s(b);n(p),n(d);const T=_.indexOf(0);return T>=0?_.subarray(0,T):_}}var rabin$1=Rabin$1,loader={};const ID_OFFSET=-8,SIZE_OFFSET=-4,ARRAYBUFFER_ID=0,STRING_ID=1,ARRAYBUFFERVIEW=1<<0,ARRAY=1<<1,VAL_ALIGN_OFFSET=5,VAL_SIGNED=1<<10,VAL_FLOAT=1<<11,VAL_MANAGED=1<<13,ARRAYBUFFERVIEW_BUFFER_OFFSET=0,ARRAYBUFFERVIEW_DATASTART_OFFSET=4,ARRAYBUFFERVIEW_DATALENGTH_OFFSET=8,ARRAYBUFFERVIEW_SIZE=12,ARRAY_LENGTH_OFFSET=12,ARRAY_SIZE=16,BIGINT=typeof BigUint64Array!="undefined",THIS=Symbol(),CHUNKSIZE=1024;function getStringImpl(t,e){const r=new Uint32Array(t),n=new Uint16Array(t);var o=r[e+SIZE_OFFSET>>>2]>>>1,s=e>>>1;if(o<=CHUNKSIZE)return String.fromCharCode.apply(String,n.subarray(s,s+o));const u=[];do{const l=n[s+CHUNKSIZE-1],h=l>=55296&&l<56320?CHUNKSIZE-1:CHUNKSIZE;u.push(String.fromCharCode.apply(String,n.subarray(s,s+=h))),o-=h}while(o>CHUNKSIZE);return u.join("")+String.fromCharCode.apply(String,n.subarray(s,s+o))}function preInstantiate(t){const e={};function r(o,s){return o?getStringImpl(o.buffer,s):"<yet unknown>"}const n=t.env=t.env||{};return n.abort=n.abort||function(s,u,l,h){const d=e.memory||n.memory;throw Error("abort: "+r(d,s)+" at "+r(d,u)+":"+l+":"+h)},n.trace=n.trace||function(s,u){const l=e.memory||n.memory;console.log("trace: "+r(l,s)+(u?" ":"")+Array.prototype.slice.call(arguments,2,2+u).join(", "))},t.Math=t.Math||Math,t.Date=t.Date||Date,e}function postInstantiate(t,e){const r=e.exports,n=r.memory,o=r.table,s=r.__alloc,u=r.__retain,l=r.__rtti_base||~0;function h(E){const A=new Uint32Array(n.buffer),S=A[l>>>2];if((E>>>=0)>=S)throw Error("invalid id: "+E);return A[(l+4>>>2)+E*2]}function d(E){const A=new Uint32Array(n.buffer),S=A[l>>>2];if((E>>>=0)>=S)throw Error("invalid id: "+E);return A[(l+4>>>2)+E*2+1]}function p(E){return 31-Math.clz32(E>>>VAL_ALIGN_OFFSET&31)}function b(E){const A=E.length,S=s(A<<1,STRING_ID),D=new Uint16Array(n.buffer);for(var I=0,F=S>>>1;I<A;++I)D[F+I]=E.charCodeAt(I);return S}t.__allocString=b;function _(E){const A=n.buffer;if(new Uint32Array(A)[E+ID_OFFSET>>>2]!==STRING_ID)throw Error("not a string: "+E);return getStringImpl(A,E)}t.__getString=_;function T(E,A,S){const D=n.buffer;if(S)switch(E){case 2:return new Float32Array(D);case 3:return new Float64Array(D)}else switch(E){case 0:return new(A?Int8Array:Uint8Array)(D);case 1:return new(A?Int16Array:Uint16Array)(D);case 2:return new(A?Int32Array:Uint32Array)(D);case 3:return new(A?BigInt64Array:BigUint64Array)(D)}throw Error("unsupported align: "+E)}function C(E,A){const S=h(E);if(!(S&(ARRAYBUFFERVIEW|ARRAY)))throw Error("not an array: "+E+" @ "+S);const D=p(S),I=A.length,F=s(I<<D,ARRAYBUFFER_ID),V=s(S&ARRAY?ARRAY_SIZE:ARRAYBUFFERVIEW_SIZE,E),G=new Uint32Array(n.buffer);G[V+ARRAYBUFFERVIEW_BUFFER_OFFSET>>>2]=u(F),G[V+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2]=F,G[V+ARRAYBUFFERVIEW_DATALENGTH_OFFSET>>>2]=I<<D,S&ARRAY&&(G[V+ARRAY_LENGTH_OFFSET>>>2]=I);const Y=T(D,S&VAL_SIGNED,S&VAL_FLOAT);if(S&VAL_MANAGED)for(let W=0;W<I;++W)Y[(F>>>D)+W]=u(A[W]);else Y.set(A,F>>>D);return V}t.__allocArray=C;function g(E){const A=new Uint32Array(n.buffer),S=A[E+ID_OFFSET>>>2],D=h(S);if(!(D&ARRAYBUFFERVIEW))throw Error("not an array: "+S);const I=p(D);var F=A[E+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];const V=D&ARRAY?A[E+ARRAY_LENGTH_OFFSET>>>2]:A[F+SIZE_OFFSET>>>2]>>>I;return T(I,D&VAL_SIGNED,D&VAL_FLOAT).subarray(F>>>=I,F+V)}t.__getArrayView=g;function B(E){const A=g(E),S=A.length,D=new Array(S);for(let I=0;I<S;I++)D[I]=A[I];return D}t.__getArray=B;function k(E){const A=n.buffer,S=new Uint32Array(A)[E+SIZE_OFFSET>>>2];return A.slice(E,E+S)}t.__getArrayBuffer=k;function R(E,A,S){return new E(x(E,A,S))}function x(E,A,S){const D=n.buffer,I=new Uint32Array(D),F=I[S+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];return new E(D,F,I[F+SIZE_OFFSET>>>2]>>>A)}t.__getInt8Array=R.bind(null,Int8Array,0),t.__getInt8ArrayView=x.bind(null,Int8Array,0),t.__getUint8Array=R.bind(null,Uint8Array,0),t.__getUint8ArrayView=x.bind(null,Uint8Array,0),t.__getUint8ClampedArray=R.bind(null,Uint8ClampedArray,0),t.__getUint8ClampedArrayView=x.bind(null,Uint8ClampedArray,0),t.__getInt16Array=R.bind(null,Int16Array,1),t.__getInt16ArrayView=x.bind(null,Int16Array,1),t.__getUint16Array=R.bind(null,Uint16Array,1),t.__getUint16ArrayView=x.bind(null,Uint16Array,1),t.__getInt32Array=R.bind(null,Int32Array,2),t.__getInt32ArrayView=x.bind(null,Int32Array,2),t.__getUint32Array=R.bind(null,Uint32Array,2),t.__getUint32ArrayView=x.bind(null,Uint32Array,2),BIGINT&&(t.__getInt64Array=R.bind(null,BigInt64Array,3),t.__getInt64ArrayView=x.bind(null,BigInt64Array,3),t.__getUint64Array=R.bind(null,BigUint64Array,3),t.__getUint64ArrayView=x.bind(null,BigUint64Array,3)),t.__getFloat32Array=R.bind(null,Float32Array,2),t.__getFloat32ArrayView=x.bind(null,Float32Array,2),t.__getFloat64Array=R.bind(null,Float64Array,3),t.__getFloat64ArrayView=x.bind(null,Float64Array,3);function v(E,A){const S=new Uint32Array(n.buffer);var D=S[E+ID_OFFSET>>>2];if(D<=S[l>>>2])do if(D==A)return!0;while(D=d(D));return!1}return t.__instanceof=v,t.memory=t.memory||n,t.table=t.table||o,demangle(r,t)}function isResponse(t){return typeof Response!="undefined"&&t instanceof Response}async function instantiate$1(t,e){return isResponse(t=await t)?instantiateStreaming(t,e):postInstantiate(preInstantiate(e||(e={})),await WebAssembly.instantiate(t instanceof WebAssembly.Module?t:await WebAssembly.compile(t),e))}loader.instantiate=instantiate$1;function instantiateSync(t,e){return postInstantiate(preInstantiate(e||(e={})),new WebAssembly.Instance(t instanceof WebAssembly.Module?t:new WebAssembly.Module(t),e))}loader.instantiateSync=instantiateSync;async function instantiateStreaming(t,e){return WebAssembly.instantiateStreaming?postInstantiate(preInstantiate(e||(e={})),(await WebAssembly.instantiateStreaming(t,e)).instance):instantiate$1(isResponse(t=await t)?t.arrayBuffer():t,e)}loader.instantiateStreaming=instantiateStreaming;function demangle(t,e){var r=e?Object.create(e):{},n=t.__argumentsLength?function(o){t.__argumentsLength.value=o}:t.__setArgumentsLength||t.__setargc||function(){};for(let o in t){if(!Object.prototype.hasOwnProperty.call(t,o))continue;const s=t[o];let u=o.split("."),l=r;for(;u.length>1;){let p=u.shift();Object.prototype.hasOwnProperty.call(l,p)||(l[p]={}),l=l[p]}let h=u[0],d=h.indexOf("#");if(d>=0){let p=h.substring(0,d),b=l[p];if(typeof b=="undefined"||!b.prototype){let _=function(...T){return _.wrap(_.prototype.constructor(0,...T))};_.prototype={valueOf:function(){return this[THIS]}},_.wrap=function(T){return Object.create(_.prototype,{[THIS]:{value:T,writable:!1}})},b&&Object.getOwnPropertyNames(b).forEach(T=>Object.defineProperty(_,T,Object.getOwnPropertyDescriptor(b,T))),l[p]=_}if(h=h.substring(d+1),l=l[p].prototype,/^(get|set):/.test(h)){if(!Object.prototype.hasOwnProperty.call(l,h=h.substring(4))){let _=t[o.replace("set:","get:")],T=t[o.replace("get:","set:")];Object.defineProperty(l,h,{get:function(){return _(this[THIS])},set:function(C){T(this[THIS],C)},enumerable:!0})}}else h==="constructor"?(l[h]=(..._)=>(n(_.length),s(..._))).original=s:(l[h]=function(..._){return n(_.length),s(this[THIS],..._)}).original=s}else/^(get|set):/.test(h)?Object.prototype.hasOwnProperty.call(l,h=h.substring(4))||Object.defineProperty(l,h,{get:t[o.replace("set:","get:")],set:t[o.replace("get:","set:")],enumerable:!0}):typeof s=="function"&&s!==n?(l[h]=(...p)=>(n(p.length),s(...p))).original=s:l[h]=s}return r}loader.demangle=demangle;const{instantiate}=loader;loadWebAssembly.supported=typeof WebAssembly!="undefined";function loadWebAssembly(t={}){if(!loadWebAssembly.supported)return null;var e=new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112]);return instantiate(new Response(new Blob([e],{type:"application/wasm"})),t)}var rabinWasm=loadWebAssembly;const Rabin=rabin$1,getRabin=rabinWasm,create=async(t,e,r,n,o)=>{const s=await getRabin();return new Rabin(s,t,e,r,n,o)};var src$2={Rabin,create};async function*rabinChunker(t,e){let r,n,o;if(e.minChunkSize&&e.maxChunkSize&&e.avgChunkSize)o=e.avgChunkSize,r=e.minChunkSize,n=e.maxChunkSize;else if(e.avgChunkSize)o=e.avgChunkSize,r=o/3,n=o+o/2;else throw errCode$3(new Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");if(r<16)throw errCode$3(new Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");n<r&&(n=r),o<r&&(o=r);const s=Math.floor(Math.log2(o));for await(const u of rabin(t,{min:r,max:n,bits:s,window:e.window,polynomial:e.polynomial}))yield u}async function*rabin(t,e){const r=await src$2.create(e.bits,e.min,e.max,e.window),n=new BufferList_1;for await(const o of t){n.append(o);const s=r.fingerprint(o);for(let u=0;u<s.length;u++){const l=s[u],h=n.slice(0,l);n.consume(l),yield h}}n.length&&(yield n.slice(0))}async function*fixedSizeChunker(t,e){let r=new BufferList_1,n=0,o=!1;const s=e.maxChunkSize;for await(const u of t)for(r.append(u),n+=u.length;n>=s;)if(yield r.slice(0,s),o=!0,s===r.length)r=new BufferList_1,n=0;else{const l=new BufferList_1;l.append(r.shallowSlice(s)),r=l,n-=s}(!o||n)&&(yield r.slice(0,n))}const identity$2=from$1({prefix:"\0",name:"identity",encode:t=>toString$1(t),decode:t=>fromString$3(t)});var identityBase=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",identity:identity$2});const base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var base2$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base2});const base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var base8$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base8});const base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"});var base10$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base10});const base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var base16$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base16,base16upper});const base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var base36$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base36,base36upper});const base64=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var base64$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",base64,base64pad,base64url,base64urlpad});const identity=from({name:"identity",code:0,encode:t=>coerce(t)});var identity$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",identity});new TextEncoder;new TextDecoder;const bases=M(M(M(M(M(M(M(M(M({},identityBase),base2$1),base8$1),base10$1),base16$1),base32$2),base36$1),base58),base64$1);M(M({},sha2),identity$1);function createCodec(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string=createCodec("utf8","u",t=>{const e=new TextDecoder("utf8");return"u"+e.decode(t)},t=>new TextEncoder().encode(t.substring(1))),ascii=createCodec("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES=M({utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii,binary:ascii},bases);function fromString(t,e="utf8"){const r=BASES[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return r.decoder.decode(`${r.prefix}${t}`)}var fromString$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",fromString});async function*validateChunks(t){for await(const e of t){if(e.length===void 0)throw errCode$3(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if(typeof e=="string"||e instanceof String)yield fromString(e.toString());else if(Array.isArray(e))yield Uint8Array.from(e);else if(e instanceof Uint8Array)yield e;else throw errCode$3(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}}function isIterable(t){return Symbol.iterator in t}function isAsyncIterable(t){return Symbol.asyncIterator in t}function contentAsAsyncIterable(t){try{if(t instanceof Uint8Array)return async function*(){yield t}();if(isIterable(t))return async function*(){yield*t}();if(isAsyncIterable(t))return t}catch{throw errCode$3(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw errCode$3(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*dagBuilder(t,e,r){for await(const n of t)if(n.path&&(n.path.substring(0,2)==="./"&&(r.wrapWithDirectory=!0),n.path=n.path.split("/").filter(o=>o&&o!==".").join("/")),n.content){let o;typeof r.chunker=="function"?o=r.chunker:r.chunker==="rabin"?o=rabinChunker:o=fixedSizeChunker;let s;typeof r.chunkValidator=="function"?s=r.chunkValidator:s=validateChunks;const u={path:n.path,mtime:n.mtime,mode:n.mode,content:o(s(contentAsAsyncIterable(n.content),r),r)};yield()=>fileBuilder(u,e,r)}else if(n.path){const o={path:n.path,mtime:n.mtime,mode:n.mode};yield()=>dirBuilder(o,e,r)}else throw new Error("Import candidate must have content or path or both")}class Dir{constructor(e,r){this.options=r||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,r){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}class DirFlat extends Dir{constructor(e,r){super(e,r);this._children={}}async put(e,r){this.cid=void 0,this.size=void 0,this._children[e]=r}get(e){return Promise.resolve(this._children[e])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async*eachChildSeries(){const e=Object.keys(this._children);for(let r=0;r<e.length;r++){const n=e[r];yield{key:n,child:this._children[n]}}}async*flush(e){const r=Object.keys(this._children),n=[];for(let d=0;d<r.length;d++){let p=this._children[r[d]];if(p instanceof Dir)for await(const b of p.flush(e))p=b,yield p;p.size!=null&&p.cid&&n.push({Name:r[d],Tsize:p.size,Hash:p.cid})}const o=new UnixFS({type:"directory",mtime:this.mtime,mode:this.mode}),s={Data:o.marshal(),Links:n},u=encode$2(prepare(s)),l=await persist(u,e,this.options),h=u.length+s.Links.reduce((d,p)=>d+(p.Tsize==null?0:p.Tsize),0);this.cid=l,this.size=h,yield{cid:l,unixfs:o,path:this.path,size:h}}}const BITS_PER_BYTE=7;var sparseArray=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(e,r){let n=this._internalPositionFor(e,!1);if(r===void 0)n!==-1&&(this._unsetInternalPos(n),this._unsetBit(e),this._changedLength=!0,this._changedData=!0);else{let o=!1;n===-1?(n=this._data.length,this._setBit(e),this._changedData=!0):o=!0,this._setInternalPos(n,e,r,o),this._changedLength=!0}}unset(e){this.set(e,void 0)}get(e){this._sortData();const r=this._internalPositionFor(e,!0);if(r!==-1)return this._data[r][1]}push(e){return this.set(this.length,e),this.length}get length(){if(this._sortData(),this._changedLength){const e=this._data[this._data.length-1];this._length=e?e[0]+1:0,this._changedLength=!1}return this._length}forEach(e){let r=0;for(;r<this.length;)e(this.get(r),r,this),r++}map(e){let r=0,n=new Array(this.length);for(;r<this.length;)n[r]=e(this.get(r),r,this),r++;return n}reduce(e,r){let n=0,o=r;for(;n<this.length;){const s=this.get(n);o=e(o,s,n),n++}return o}find(e){let r=0,n,o;for(;r<this.length&&!n;)o=this.get(r),n=e(o),r++;return n?o:void 0}_internalPositionFor(e,r){const n=this._bytePosFor(e,r);if(n>=this._bitArrays.length)return-1;const o=this._bitArrays[n],s=e-n*BITS_PER_BYTE;if(!((o&1<<s)>0))return-1;const l=this._bitArrays.slice(0,n).reduce(popCountReduce,0),h=~(4294967295<<s+1),d=popCount(o&h);return l+d-1}_bytePosFor(e,r){const n=Math.floor(e/BITS_PER_BYTE),o=n+1;for(;!r&&this._bitArrays.length<o;)this._bitArrays.push(0);return n}_setBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]|=1<<e-r*BITS_PER_BYTE}_unsetBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]&=~(1<<e-r*BITS_PER_BYTE)}_setInternalPos(e,r,n,o){const s=this._data,u=[r,n];if(o)this._sortData(),s[e]=u;else{if(s.length)if(s[s.length-1][0]>=r)s.push(u);else if(s[0][0]<=r)s.unshift(u);else{const l=Math.round(s.length/2);this._data=s.slice(0,l).concat(u).concat(s.slice(l))}else this._data.push(u);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(e){this._data.splice(e,1)}_sortData(){this._changedData&&this._data.sort(sortInternal),this._changedData=!1}bitField(){const e=[];let r=8,n=0,o=0,s;const u=this._bitArrays.slice();for(;u.length||n;){n===0&&(s=u.shift(),n=7);const h=Math.min(n,r),d=~(255<<h);o|=(s&d)<<8-r,s=s>>>h,n-=h,r-=h,(!r||!n&&!u.length)&&(e.push(o),o=0,r=8)}for(var l=e.length-1;l>0&&e[l]===0;l--)e.pop();return e}compactArray(){return this._sortData(),this._data.map(valueOnly)}};function popCountReduce(t,e){return t+popCount(e)}function popCount(t){let e=t;return e=e-(e>>1&1431655765),e=(e&858993459)+(e>>2&858993459),(e+(e>>4)&252645135)*16843009>>24}function sortInternal(t,e){return t[0]-e[0]}function valueOnly(t){return t[1]}var require$$1$3=getAugmentedNamespace(fromString$1);const SparseArray=sparseArray,{fromString:uint8ArrayFromString$1}=require$$1$3;class Bucket$1{constructor(e,r,n=0){this._options=e,this._popCount=0,this._parent=r,this._posAtParent=n,this._children=new SparseArray,this.key=null}async put(e,r){const n=await this._findNewBucketAndPos(e);await n.bucket._putAt(n,e,r)}async get(e){const r=await this._findChild(e);if(r)return r.value}async del(e){const r=await this._findPlace(e),n=r.bucket._at(r.pos);n&&n.key===e&&r.bucket._delAt(r.pos)}leafCount(){return this._children.compactArray().reduce((r,n)=>n instanceof Bucket$1?r+n.leafCount():r+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const e=this._children.compactArray();for(const r of e)r instanceof Bucket$1?yield*r.eachLeafSeries():yield r;return[]}serialize(e,r){const n=[];return r(this._children.reduce((o,s,u)=>(s&&(s instanceof Bucket$1?o.push(s.serialize(e,r)):o.push(e(s,u))),o),n))}asyncTransform(e,r){return asyncTransformBucket(this,e,r)}toJSON(){return this.serialize(mapNode,reduceNodes)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(e){const r=await this._findPlace(e),n=r.bucket._at(r.pos);if(!(n instanceof Bucket$1)&&n&&n.key===e)return n}async _findPlace(e){const r=this._options.hash(typeof e=="string"?uint8ArrayFromString$1(e):e),n=await r.take(this._options.bits),o=this._children.get(n);return o instanceof Bucket$1?o._findPlace(r):{bucket:this,pos:n,hash:r,existingChild:o}}async _findNewBucketAndPos(e){const r=await this._findPlace(e);if(r.existingChild&&r.existingChild.key!==e){const n=new Bucket$1(this._options,r.bucket,r.pos);r.bucket._putObjectAt(r.pos,n);const o=await n._findPlace(r.existingChild.hash);return o.bucket._putAt(o,r.existingChild.key,r.existingChild.value),n._findNewBucketAndPos(r.hash)}return r}_putAt(e,r,n){this._putObjectAt(e.pos,{key:r,value:n,hash:e.hash})}_putObjectAt(e,r){this._children.get(e)||this._popCount++,this._children.set(e,r)}_delAt(e){if(e===-1)throw new Error("Invalid position");this._children.get(e)&&this._popCount--,this._children.unset(e),this._level()}_level(){if(this._parent&&this._popCount<=1)if(this._popCount===1){const e=this._children.find(exists);if(e&&!(e instanceof Bucket$1)){const r=e.hash;r.untake(this._options.bits);const n={pos:this._posAtParent,hash:r,bucket:this._parent};this._parent._putAt(n,e.key,e.value)}}else this._parent._delAt(this._posAtParent)}_at(e){return this._children.get(e)}}function exists(t){return Boolean(t)}function mapNode(t,e){return t.key}function reduceNodes(t){return t}async function asyncTransformBucket(t,e,r){const n=[];for(const o of t._children.compactArray())if(o instanceof Bucket$1)await asyncTransformBucket(o,e,r);else{const s=await e(o);n.push({bitField:t._children.bitField(),children:s})}return r(n)}var bucket=Bucket$1,consumableHash={exports:{}};const START_MASKS=[255,254,252,248,240,224,192,128],STOP_MASKS=[1,3,7,15,31,63,127,255];var consumableBuffer=class{constructor(e){this._value=e,this._currentBytePos=e.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(e){let r=e,n=0;for(;r&&this._haveBits();){const o=this._value[this._currentBytePos],s=this._currentBitPos+1,u=Math.min(s,r),l=byteBitsToInt(o,s-u,u);n=(n<<u)+l,r-=u,this._currentBitPos-=u,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return n}untake(e){for(this._currentBitPos+=e;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function byteBitsToInt(t,e,r){const n=maskFor(e,r);return(t&n)>>>e}function maskFor(t,e){return START_MASKS[t]&STOP_MASKS[Math.min(e+t-1,7)]}function concat(t,e){e||(e=t.reduce((o,s)=>o+s.length,0));const r=new Uint8Array(e);let n=0;for(const o of t)r.set(o,n),n+=o.length;return r}var concat$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",concat}),require$$1$2=getAugmentedNamespace(concat$1);const ConsumableBuffer=consumableBuffer,{concat:uint8ArrayConcat}=require$$1$2;function wrapHash$1(t){function e(r){return r instanceof InfiniteHash?r:new InfiniteHash(r,t)}return e}class InfiniteHash{constructor(e,r){if(!(e instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=e,this._hashFn=r,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(e){let r=e;for(;this._availableBits<r;)await this._produceMoreBits();let n=0;for(;r>0;){const o=this._buffers[this._currentBufferIndex],s=Math.min(o.availableBits(),r),u=o.take(s);n=(n<<s)+u,r-=s,this._availableBits-=s,o.availableBits()===0&&this._currentBufferIndex++}return n}untake(e){let r=e;for(;r>0;){const n=this._buffers[this._currentBufferIndex],o=Math.min(n.totalBits()-n.availableBits(),r);n.untake(o),r-=o,this._availableBits+=o,this._currentBufferIndex>0&&n.totalBits()===n.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const e=this._depth?uint8ArrayConcat([this._value,Uint8Array.from([this._depth])]):this._value,r=await this._hashFn(e),n=new ConsumableBuffer(r);this._buffers.push(n),this._availableBits+=n.availableBits()}}consumableHash.exports=wrapHash$1;consumableHash.exports.InfiniteHash=InfiniteHash;const Bucket=bucket,wrapHash=consumableHash.exports;function createHAMT(t){if(!t||!t.hashFn)throw new Error("please define an options.hashFn");const e={bits:t.bits||8,hash:wrapHash(t.hashFn)};return new Bucket(e)}var src$1={createHAMT,Bucket};class DirSharded extends Dir{constructor(e,r){super(e,r);this._bucket=src$1.createHAMT({hashFn:r.hamtHashFn,bits:r.hamtBucketBits})}async put(e,r){await this._bucket.put(e,r)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:r}of this._bucket.eachLeafSeries())yield{key:e,child:r}}async*flush(e){for await(const r of flush(this._bucket,e,this,this.options))yield Z(M({},r),{path:this.path})}}async function*flush(t,e,r,n){const o=t._children,s=[];let u=0;for(let T=0;T<o.length;T++){const C=o.get(T);if(!C)continue;const g=T.toString(16).toUpperCase().padStart(2,"0");if(C instanceof src$1.Bucket){let B;for await(const k of await flush(C,e,null,n))B=k;if(!B)throw new Error("Could not flush sharded directory, no subshard found");s.push({Name:g,Tsize:B.size,Hash:B.cid}),u+=B.size}else if(typeof C.value.flush=="function"){const B=C.value;let k;for await(const x of B.flush(e))k=x,yield k;const R=g+C.key;s.push({Name:R,Tsize:k.size,Hash:k.cid}),u+=k.size}else{const B=C.value;if(!B.cid)continue;const k=g+C.key,R=B.size;s.push({Name:k,Tsize:R,Hash:B.cid}),u+=R}}const l=Uint8Array.from(o.bitField().reverse()),h=new UnixFS({type:"hamt-sharded-directory",data:l,fanout:t.tableSize(),hashType:n.hamtHashCode,mtime:r&&r.mtime,mode:r&&r.mode}),d={Data:h.marshal(),Links:s},p=encode$2(prepare(d)),b=await persist(p,e,n),_=p.length+u;yield{cid:b,unixfs:h,size:_}}async function flatToShard(t,e,r,n){let o=e;e instanceof DirFlat&&e.directChildrenCount()>=r&&(o=await convertToShard(e,n));const s=o.parent;if(s){if(o!==e){if(t&&(t.parent=o),!o.parentKey)throw new Error("No parent key found");await s.put(o.parentKey,o)}return flatToShard(o,s,r,n)}return o}async function convertToShard(t,e){const r=new DirSharded({root:t.root,dir:!0,parent:t.parent,parentKey:t.parentKey,path:t.path,dirty:t.dirty,flat:!1,mtime:t.mtime,mode:t.mode},e);for await(const{key:n,child:o}of t.eachChildSeries())await r.put(n,o);return r}const toPathComponents$1=(t="")=>(t.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean);async function addToTree(t,e,r){const n=toPathComponents$1(t.path||""),o=n.length-1;let s=e,u="";for(let l=0;l<n.length;l++){const h=n[l];u+=`${u?"/":""}${h}`;const d=l===o;if(s.dirty=!0,s.cid=void 0,s.size=void 0,d)await s.put(h,t),e=await flatToShard(null,s,r.shardSplitThreshold,r);else{let p=await s.get(h);(!p||!(p instanceof Dir))&&(p=new DirFlat({root:!1,dir:!0,parent:s,parentKey:h,path:u,dirty:!0,flat:!0,mtime:p&&p.unixfs&&p.unixfs.mtime,mode:p&&p.unixfs&&p.unixfs.mode},r)),await s.put(h,p),s=p}}return e}async function*flushAndYield(t,e){if(!(t instanceof Dir)){t&&t.unixfs&&t.unixfs.isDirectory()&&(yield t);return}yield*t.flush(e)}async function*treeBuilder(t,e,r){let n=new DirFlat({root:!0,dir:!0,path:"",dirty:!0,flat:!0},r);for await(const o of t)!o||(n=await addToTree(o,n,r),(!o.unixfs||!o.unixfs.isDirectory())&&(yield o));if(r.wrapWithDirectory)yield*flushAndYield(n,e);else for await(const o of n.eachChildSeries())!o||(yield*flushAndYield(o.child,e))}async function*importer(t,e,r={}){const n=defaultOptions$1(r);let o;typeof r.dagBuilder=="function"?o=r.dagBuilder:o=dagBuilder;let s;typeof r.treeBuilder=="function"?s=r.treeBuilder:s=treeBuilder;let u;Symbol.asyncIterator in t||Symbol.iterator in t?u=t:u=[t];for await(const l of s(itParallelBatch(o(u,e,n),n.fileImportConcurrency),e,n))yield{cid:l.cid,path:l.path,unixfs:l.unixfs,size:l.size}}async function*browserReadableStreamToIt$1(t,e={}){const r=t.getReader();try{for(;;){const n=await r.read();if(n.done)return;yield n.value}}finally{e.preventCancel!==!0&&r.cancel(),r.releaseLock()}}var browserReadablestreamToIt=browserReadableStreamToIt$1;const browserReadableStreamToIt=browserReadablestreamToIt;function blobToIt$1(t){return typeof t.stream=="function"?browserReadableStreamToIt(t.stream()):browserReadableStreamToIt(new Response(t).body)}var blobToIt_1=blobToIt$1;function peekableIterator(t){const[e,r]=t[Symbol.asyncIterator]?[t[Symbol.asyncIterator](),Symbol.asyncIterator]:[t[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:o=>{n.push(o)},next:()=>n.length?{done:!1,value:n.shift()}:e.next(),[r](){return this}}}var itPeekable$2=peekableIterator;const map$2=async function*(t,e){for await(const r of t)yield e(r)};var itMap=map$2;function isBytes$2(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}function isBlob$2(t){return t.constructor&&(t.constructor.name==="Blob"||t.constructor.name==="File")&&typeof t.stream=="function"}function isFileObject$1(t){return typeof t=="object"&&(t.path||t.content)}const isReadableStream$2=t=>t&&typeof t.getReader=="function";var utils={isBytes:isBytes$2,isBlob:isBlob$2,isFileObject:isFileObject$1,isReadableStream:isReadableStream$2};const errCode$2=errCode$3,{fromString:uint8ArrayFromString}=require$$1$3,browserStreamToIt$1=browserReadablestreamToIt,blobToIt=blobToIt_1,itPeekable$1=itPeekable$2,all$1=itAll,map$1=itMap,{isBytes:isBytes$1,isReadableStream:isReadableStream$1,isBlob:isBlob$1}=utils;async function*toAsyncIterable(t){if(isBytes$1(t)){yield toBytes(t);return}if(typeof t=="string"||t instanceof String){yield toBytes(t.toString());return}if(isBlob$1(t)){yield*blobToIt(t);return}if(isReadableStream$1(t)&&(t=browserStreamToIt$1(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const e=itPeekable$1(t),{value:r,done:n}=await e.peek();if(n){yield*[];return}if(e.push(r),Number.isInteger(r)){yield Uint8Array.from(await all$1(e));return}if(isBytes$1(r)||typeof r=="string"||r instanceof String){yield*map$1(e,toBytes);return}}throw errCode$2(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT")}function toBytes(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Array.isArray(t)?Uint8Array.from(t):uint8ArrayFromString(t.toString())}var normaliseContent$1=toAsyncIterable,require$$5=getAugmentedNamespace(src$3);const errCode$1=errCode$3,browserStreamToIt=browserReadablestreamToIt,itPeekable=itPeekable$2,map=itMap,{isBytes,isBlob,isReadableStream,isFileObject}=utils,{parseMtime,parseMode}=require$$5;var normaliseInput$1=async function*t(e,r){if(e==null)throw errCode$1(new Error(`Unexpected input: ${e}`),"ERR_UNEXPECTED_INPUT");if(typeof e=="string"||e instanceof String){yield toFileObject(e.toString(),r);return}if(isBytes(e)||isBlob(e)){yield toFileObject(e,r);return}if(isReadableStream(e)&&(e=browserStreamToIt(e)),Symbol.iterator in e||Symbol.asyncIterator in e){const n=itPeekable(e),{value:o,done:s}=await n.peek();if(s){yield*[];return}if(n.push(o),Number.isInteger(o)||isBytes(o)){yield toFileObject(n,r);return}if(isFileObject(o)||isBlob(o)||typeof o=="string"||o instanceof String){yield*map(n,u=>toFileObject(u,r));return}if(o[Symbol.iterator]||o[Symbol.asyncIterator]||isReadableStream(o)){yield*map(n,u=>toFileObject(u,r));return}}if(isFileObject(e)){yield toFileObject(e,r);return}throw errCode$1(new Error("Unexpected input: "+typeof e),"ERR_UNEXPECTED_INPUT")};async function toFileObject(t,e){const{path:r,mode:n,mtime:o,content:s}=t,u={path:r||"",mode:parseMode(n),mtime:parseMtime(o)};return s?u.content=await e(s):r||(u.content=await e(t)),u}const normaliseContent=normaliseContent$1,normalise=normaliseInput$1;function normaliseInput(t){return normalise(t,normaliseContent)}var normaliseInput_1={normaliseInput};const drain$1=async t=>{for await(const e of t);};var itDrain=drain$1;const filter$1=async function*(t,e){for await(const r of t)await e(r)&&(yield r)};var itFilter=filter$1;const take$1=async function*(t,e){let r=0;if(!(e<1)){for await(const n of t)if(yield n,r++,r===e)return}};var itTake=take$1;const drain=itDrain,filter=itFilter,take=itTake,all=itAll,sortAll=(t,e)=>async function*(){yield*(await all(t)).sort(e)}();class BlockstoreAdapter$1{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,r,n){return Promise.reject(new Error(".put is not implemented"))}get(e,r){return Promise.reject(new Error(".get is not implemented"))}has(e,r){return Promise.reject(new Error(".has is not implemented"))}delete(e,r){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,r={}){for await(const{key:n,value:o}of e)await this.put(n,o,r),yield{key:n,value:o}}async*getMany(e,r={}){for await(const n of e)yield this.get(n,r)}async*deleteMany(e,r={}){for await(const n of e)await this.delete(n,r),yield n}batch(){let e=[],r=[];return{put(n,o){e.push({key:n,value:o})},delete(n){r.push(n)},commit:async n=>{await drain(this.putMany(e,n)),e=[],await drain(this.deleteMany(r,n)),r=[]}}}async*_all(e,r){throw new Error("._all is not implemented")}async*_allKeys(e,r){throw new Error("._allKeys is not implemented")}query(e,r){let n=this._all(e,r);if(e.prefix!=null&&(n=filter(n,o=>o.key.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,s)=>filter(o,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,s)=>sortAll(o,s),n)),e.offset!=null){let o=0;n=filter(n,()=>o++>=(e.offset||0))}return e.limit!=null&&(n=take(n,e.limit)),n}queryKeys(e,r){let n=this._allKeys(e,r);if(e.prefix!=null&&(n=filter(n,o=>o.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((o,s)=>filter(o,s),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((o,s)=>sortAll(o,s),n)),e.offset!=null){let o=0;n=filter(n,()=>o++>=e.offset)}return e.limit!=null&&(n=take(n,e.limit)),n}}var adapter=BlockstoreAdapter$1,require$$1$1=getAugmentedNamespace(base32$2),require$$2=getAugmentedNamespace(raw$1),require$$3=getAugmentedNamespace(cid),require$$4=getAugmentedNamespace(digest);const errCode=errCode$3;function notFoundError(t){return t=t||new Error("Not Found"),errCode(t,"ERR_NOT_FOUND")}var errors={notFoundError};const Adapter=adapter,{base32}=require$$1$1,raw=require$$2,{CID}=require$$3,Digest=require$$4,Errors=errors;class MemoryBlockstore$1 extends Adapter{constructor(){super();this.data={}}open(){return Promise.resolve()}close(){return Promise.resolve()}async put(e,r){this.data[base32.encode(e.multihash.bytes)]=r}async get(e){if(!await this.has(e))throw Errors.notFoundError();return this.data[base32.encode(e.multihash.bytes)]}async has(e){return this.data[base32.encode(e.multihash.bytes)]!==void 0}async delete(e){delete this.data[base32.encode(e.multihash.bytes)]}async*_all(){yield*Object.entries(this.data).map(([e,r])=>({key:CID.createV1(raw.code,Digest.decode(base32.decode(e))),value:r}))}async*_allKeys(){yield*Object.entries(this.data).map(([e])=>CID.createV1(raw.code,Digest.decode(base32.decode(e))))}}var memory=MemoryBlockstore$1;const BlockstoreAdapter=adapter,MemoryBlockstore=memory;var src={BlockstoreAdapter,MemoryBlockstore};class MemoryBlockStore extends src.BlockstoreAdapter{constructor(){super();this.store=new Map}async*blocks(){for(const[e,r]of this.store.entries())yield{cid:CID$1.parse(e),bytes:r}}put(e,r){return this.store.set(e.toString(),r),Promise.resolve()}get(e){const r=this.store.get(e.toString());if(!r)throw new Error(`block with cid ${e.toString()} no found`);return Promise.resolve(r)}has(e){return Promise.resolve(this.store.has(e.toString()))}close(){return this.store.clear(),Promise.resolve()}}const unixfsImporterOptionsDefault={cidVersion:1,chunker:"fixed",maxChunkSize:262144,hasher:sha256,rawLeaves:!0,wrapWithDirectory:!0,maxChildrenPerNode:174};async function pack({input:t,blockstore:e,hasher:r,maxChunkSize:n,maxChildrenPerNode:o,wrapWithDirectory:s}){if(!t||Array.isArray(t)&&!t.length)throw new Error("missing input file(s)");const u=e||new MemoryBlockStore,l=await itLast(pipe$1(normaliseInput_1.normaliseInput(t),g=>importer(g,u,Z(M({},unixfsImporterOptionsDefault),{hasher:r||unixfsImporterOptionsDefault.hasher,maxChunkSize:n||unixfsImporterOptionsDefault.maxChunkSize,maxChildrenPerNode:o||unixfsImporterOptionsDefault.maxChildrenPerNode,wrapWithDirectory:s===!1?!1:unixfsImporterOptionsDefault.wrapWithDirectory}))));if(!l||!l.cid)throw new Error("given input could not be parsed correctly");const h=l.cid,{writer:d,out:p}=await CarWriter.create([h]),b=p[Symbol.asyncIterator]();let _;const T=async()=>{for await(const g of u.blocks())await d.put(g);await d.close(),e||await u.close()},C={[Symbol.asyncIterator](){if(_!=null)throw new Error("Multiple iterator not supported");return _=T(),{async next(){const g=await b.next();return g.done&&await _,g}}}};return{root:h,out:C}}var __viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",default:__viteBrowserExternal}),require$$1=getAugmentedNamespace(__viteBrowserExternal$1),immutable=extend,hasOwnProperty=Object.prototype.hasOwnProperty;function extend(){for(var t={},e=0;e<arguments.length;e++){var r=arguments[e];for(var n in r)hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}var qs=require$$1,url=require$$1,xtend=immutable;function hasRel(t){return t&&t.rel}function intoRels(t,e){function r(n){t[n]=xtend(e,{rel:n})}return e.rel.split(/\s+/).forEach(r),t}function createObjects(t,e){var r=e.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);return r&&(t[r[1]]=r[2]),t}function parseLink(t){try{var e=t.match(/<?([^>]*)>(.*)/),r=e[1],n=e[2].split(";"),o=url.parse(r),s=qs.parse(o.query);n.shift();var u=n.reduce(createObjects,{});return u=xtend(s,u),u.url=r,u}catch{return null}}var parseLinkHeader=function(t){return t?t.split(/,\s*</).map(parseLink).filter(hasRel).reduce(intoRels,{}):null};const CID_CBOR_TAG=42;function cidEncoder(t){if(t.asCID!==t)return null;const e=CID$1.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token(Type.tag,CID_CBOR_TAG),new Token(Type.bytes,r)]}function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions={float64:!0,typeEncoders:{Object:cidEncoder,undefined:undefinedEncoder,number:numberEncoder}};function cidDecoder(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID$1.decode(t.subarray(1))}const decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions.tags[CID_CBOR_TAG]=cidDecoder;const name="dag-cbor",code=113,encode=t=>encode$4(t,encodeOptions),decode=t=>decode$4(t,decodeOptions);var cbor=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",name,code,encode,decode});const hashFn=async function(t){return(await murmur3128.encode(t)).slice(0,8).reverse()},addLinksToHamtBucket=(t,e,r)=>Promise.all(t.map(n=>{if(n.Name==null)throw new Error("Unexpected Link without a Name");if(n.Name.length===2){const o=parseInt(n.Name,16);return e._putObjectAt(o,new src$1.Bucket({hash:r._options.hash,bits:r._options.bits},e,o))}return r.put(n.Name.substring(2),!0)})),toPrefix=t=>t.toString(16).toUpperCase().padStart(2,"0").substring(0,2),toBucketPath=t=>{let e=t.bucket;const r=[];for(;e._parent;)r.push(e),e=e._parent;return r.push(e),r.reverse()},findShardCid=async(t,e,r,n,o)=>{if(!n){const p=src$1.createHAMT({hashFn});n={rootBucket:p,hamtDepth:1,lastBucket:p}}await addLinksToHamtBucket(t.Links,n.lastBucket,n.rootBucket);const s=await n.rootBucket._findNewBucketAndPos(e);let u=toPrefix(s.pos);const l=toBucketPath(s);l.length>n.hamtDepth&&(n.lastBucket=l[n.hamtDepth],u=toPrefix(n.lastBucket._posAtParent));const h=t.Links.find(p=>{if(p.Name==null)return!1;const b=p.Name.substring(0,2),_=p.Name.substring(2);return!(b!==u||_&&_!==e)});if(!h)return null;if(h.Name!=null&&h.Name.substring(2)===e)return h.Hash;n.hamtDepth++;const d=await r.get(h.Hash,o);return t=decode$2(d),findShardCid(t,e,r,n,o)};function extractDataFromBlock(t,e,r,n){const o=t.length,s=e+o;return r>=s||n<e?new Uint8Array(0):(n>=e&&n<s&&(t=t.slice(0,n-e)),r>=e&&r<s&&(t=t.slice(r-e)),t)}const validateOffsetAndLength=(t,e,r)=>{if(e||(e=0),e<0)throw errCode$3(new Error("Offset must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(e>t)throw errCode$3(new Error("Offset must be less than the file size"),"ERR_INVALID_PARAMS");if(!r&&r!==0&&(r=t-e),r<0)throw errCode$3(new Error("Length must be greater than or equal to 0"),"ERR_INVALID_PARAMS");return e+r>t&&(r=t-e),{offset:e,length:r}};async function*emitBytes(t,e,r,n,o=0,s){if(e instanceof Uint8Array){const h=extractDataFromBlock(e,o,r,n);return h.length&&(yield h),o+=h.length,o}if(e.Data==null)throw errCode$3(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");let u;try{u=UnixFS.unmarshal(e.Data)}catch(h){throw errCode$3(h,"ERR_NOT_UNIXFS")}if(u.data&&u.data.length){const h=extractDataFromBlock(u.data,o,r,n);h.length&&(yield h),o+=u.data.length}let l=o;for(let h=0;h<e.Links.length;h++){const d=e.Links[h],p=o+u.blockSizes[h];if(r>=l&&r<p||n>l&&n<=p||r<l&&n>p){const b=await t.get(d.Hash,{signal:s.signal});let _;switch(d.Hash.code){case code$3:_=await decode$2(b);break;case code$2:_=b;break;case code:_=await decode(b);break;default:throw Error(`Unsupported codec: ${d.Hash.code}`)}for await(const T of emitBytes(t,_,r,n,o,s))o+=T.length,yield T}o=p,l=p+1}}const fileContent=(t,e,r,n,o,s,u)=>{function l(h={}){const d=r.fileSize();if(d===void 0)throw new Error("File was a directory");const{offset:p,length:b}=validateOffsetAndLength(d,h.offset,h.length),_=p,T=p+b;return emitBytes(u,e,_,T,0,h)}return l},directoryContent=(t,e,r,n,o,s,u)=>{async function*l(h={}){const d=h.offset||0,p=h.length||e.Links.length,b=e.Links.slice(d,p);for(const _ of b){const T=await o(_.Hash,_.Name||"",`${n}/${_.Name||""}`,[],s+1,u,h);T.entry&&(yield T.entry)}}return l},hamtShardedDirectoryContent=(t,e,r,n,o,s,u)=>{function l(h={}){return listDirectory(e,n,o,s,u,h)}return l};async function*listDirectory(t,e,r,n,o,s){const u=t.Links;for(const l of u){const h=l.Name!=null?l.Name.substring(2):null;if(h)yield(await r(l.Hash,h,`${e}/${h}`,[],n+1,o,s)).entry;else{const d=await o.get(l.Hash);t=decode$2(d);for await(const p of listDirectory(t,e,r,n,o,s))yield p}}}const findLinkCid=(t,e)=>{const r=t.Links.find(n=>n.Name===e);return r&&r.Hash},contentExporters={raw:fileContent,file:fileContent,directory:directoryContent,"hamt-sharded-directory":hamtShardedDirectoryContent,metadata:(t,e,r,n,o,s,u)=>()=>[],symlink:(t,e,r,n,o,s,u)=>()=>[]},unixFsResolver=async(t,e,r,n,o,s,u,l)=>{const h=await u.get(t,l),d=decode$2(h);let p,b;if(e||(e=t.toString()),d.Data==null)throw errCode$3(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{p=UnixFS.unmarshal(d.Data)}catch(_){throw errCode$3(_,"ERR_NOT_UNIXFS")}if(r||(r=e),n.length){let _;if(p&&p.type==="hamt-sharded-directory"?_=await findShardCid(d,n[0],u):_=findLinkCid(d,n[0]),!_)throw errCode$3(new Error("file does not exist"),"ERR_NOT_FOUND");const T=n.shift(),C=`${r}/${T}`;b={cid:_,toResolve:n,name:T||"",path:C}}return{entry:{type:p.isDirectory()?"directory":"file",name:e,path:r,cid:t,content:contentExporters[p.type](t,d,p,r,o,s,u),unixfs:p,depth:s,node:d,size:p.fileSize()},next:b}},rawContent$1=t=>{async function*e(r={}){const{offset:n,length:o}=validateOffsetAndLength(t.length,r.offset,r.length);yield extractDataFromBlock(t,0,n,n+o)}return e},resolve$3=async(t,e,r,n,o,s,u,l)=>{if(n.length)throw errCode$3(new Error(`No link named ${r} found in raw node ${t}`),"ERR_NOT_FOUND");const h=await u.get(t,l);return{entry:{type:"raw",name:e,path:r,cid:t,content:rawContent$1(h),depth:s,size:h.length,node:h}}},resolve$2=async(t,e,r,n,o,s,u,l)=>{const h=await u.get(t),d=decode(h);let p=d,b=r;for(;n.length;){const _=n[0];if(_ in p){n.shift(),b=`${b}/${_}`;const T=CID$1.asCID(p[_]);if(T)return{entry:{type:"object",name:e,path:r,cid:t,node:h,depth:s,size:h.length,content:async function*(){yield d}},next:{cid:T,name:_,path:b,toResolve:n}};p=p[_]}else throw errCode$3(new Error(`No property named ${_} found in cbor node ${t}`),"ERR_NO_PROP")}return{entry:{type:"object",name:e,path:r,cid:t,node:h,depth:s,size:h.length,content:async function*(){yield d}}}},rawContent=t=>{async function*e(r={}){const{offset:n,length:o}=validateOffsetAndLength(t.length,r.offset,r.length);yield extractDataFromBlock(t,0,n,n+o)}return e},resolve$1=async(t,e,r,n,o,s,u,l)=>{if(n.length)throw errCode$3(new Error(`No link named ${r} found in raw node ${t}`),"ERR_NOT_FOUND");const h=await decode$6(t.multihash.bytes);return{entry:{type:"identity",name:e,path:r,cid:t,content:rawContent(h.digest),depth:s,size:h.digest.length,node:h.digest}}},resolvers={[code$3]:unixFsResolver,[code$2]:resolve$3,[code]:resolve$2,[identity.code]:resolve$1};function resolve(t,e,r,n,o,s,u){const l=resolvers[t.code];if(!l)throw errCode$3(new Error(`No resolver for code ${t.code}`),"ERR_NO_RESOLVER");return l(t,e,r,n,resolve,o,s,u)}const toPathComponents=(t="")=>(t.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean),cidAndRest=t=>{if(t instanceof Uint8Array)return{cid:CID$1.decode(t),toResolve:[]};const e=CID$1.asCID(t);if(e)return{cid:e,toResolve:[]};if(typeof t=="string"){t.indexOf("/ipfs/")===0&&(t=t.substring(6));const r=toPathComponents(t);return{cid:CID$1.parse(r[0]),toResolve:r.slice(1)}}throw errCode$3(new Error(`Unknown path type ${t}`),"ERR_BAD_PATH")};async function*walkPath(t,e,r={}){let{cid:n,toResolve:o}=cidAndRest(t),s=n.toString(),u=s;const l=o.length;for(;;){const h=await resolve(n,s,u,o,l,e,r);if(!h.entry&&!h.next)throw errCode$3(new Error(`Could not resolve ${t}`),"ERR_NOT_FOUND");if(h.entry&&(yield h.entry),!h.next)return;o=h.next.toResolve,n=h.next.cid,s=h.next.name,u=h.next.path}}async function exporter(t,e,r={}){const n=await itLast(walkPath(t,e,r));if(!n)throw errCode$3(new Error(`Could not resolve ${t}`),"ERR_NOT_FOUND");return n}async function*recursive(t,e,r={}){const n=await exporter(t,e,r);if(!n)return;if(yield n,n.type==="directory")for await(const s of o(n,r))yield s;async function*o(s,u){for await(const l of s.content(u))yield l,!(l instanceof Uint8Array)&&l.type==="directory"&&(yield*o(l,u))}}function equals(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0}class VerifyingGetOnlyBlockStore extends src.BlockstoreAdapter{constructor(e){super();this.store=e}async get(e){const r=await this.store.get(e);if(!r)throw new Error(`Incomplete CAR. Block missing for CID ${e}`);if(!isValid({cid:e,bytes:r}))throw new Error(`Invalid CAR. Hash of block data does not match CID ${e}`);return r}static fromBlockstore(e){return new VerifyingGetOnlyBlockStore(e)}static fromCarReader(e){return new VerifyingGetOnlyBlockStore({get:async r=>{const n=await e.get(r);return n==null?void 0:n.bytes}})}}async function isValid({cid:t,bytes:e}){const r=await sha256.digest(e);return equals(r.digest,t.multihash.digest)}async function*unpackStream(t,{roots:e,blockstore:r}={}){const n=await CarBlockIterator.fromIterable(asAsyncIterable(t)),o=r||new MemoryBlockStore;for await(const u of n)await o.put(u.cid,u.bytes);const s=VerifyingGetOnlyBlockStore.fromBlockstore(o);(!e||e.length===0)&&(e=await n.getRoots());for(const u of e)yield*recursive(u,s)}function asAsyncIterable(t){return Symbol.asyncIterator in t?t:browserReadablestreamToIt(t)}const readonly=({enumerable:t=!0,configurable:e=!1}={})=>({enumerable:t,configurable:e,writable:!1}),links=function*(t,e){if(t!=null&&!(t instanceof Uint8Array))for(const[r,n]of Object.entries(t)){const o=[...e,r];if(n!=null&&typeof n=="object")if(Array.isArray(n))for(const[s,u]of n.entries()){const l=[...o,s],h=CID$1.asCID(u);h?yield[l.join("/"),h]:typeof u=="object"&&(yield*links(u,l))}else{const s=CID$1.asCID(n);s?yield[o.join("/"),s]:yield*links(n,o)}}},tree=function*(t,e){if(t!=null)for(const[r,n]of Object.entries(t)){const o=[...e,r];if(yield o.join("/"),n!=null&&!(n instanceof Uint8Array)&&typeof n=="object"&&!CID$1.asCID(n))if(Array.isArray(n))for(const[s,u]of n.entries()){const l=[...o,s];yield l.join("/"),typeof u=="object"&&!CID$1.asCID(u)&&(yield*tree(u,l))}else yield*tree(n,o)}},get=(t,e)=>{let r=t;for(const[n,o]of e.entries()){if(r=r[o],r==null)throw new Error(`Object has no property at ${e.slice(0,n+1).map(u=>`[${JSON.stringify(u)}]`).join("")}`);const s=CID$1.asCID(r);if(s)return{value:s,remaining:e.slice(n+1).join("/")}}return{value:r}};class Block{constructor({cid:e,bytes:r,value:n}){if(!e||!r||typeof n=="undefined")throw new Error("Missing required argument");this.cid=e,this.bytes=r,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:readonly(),bytes:readonly(),value:readonly(),asBlock:readonly()})}links(){return links(this.value,[])}tree(){return tree(this.value,[])}get(e="/"){return get(this.value,e.split("/").filter(Boolean))}}class TreewalkCarSplitter{constructor(e,r,n={}){if(typeof r!="number"||r<=0)throw new Error("invalid target chunk size");this._reader=e,this._targetSize=r,this._decoders=[pb,raw$1,cbor,...n.decoders||[]]}async*cars(){const e=await this._reader.getRoots();if(e.length!==1)throw new Error(`unexpected number of roots: ${e.length}`);let r;for await(const n of this._cars(e[0]))r=n.channel,n.out&&(yield n.out);if(!r)throw new Error("missing CAR writer channel");r.writer.close(),yield r.out}async _get(e){const r=await this._reader.get(e);if(!r)throw new Error(`missing block for ${e}`);const{bytes:n}=r,o=this._decoders.find(s=>s.code===e.code);if(!o)throw new Error(`missing decoder for ${e.code}`);return new Block({cid:e,bytes:n,value:o.decode(n)})}async*_cars(e,r=[],n=void 0){const o=await this._get(e);if(n=n||Object.assign(CarWriter.create(e),{size:0}),n.size>0&&n.size+o.bytes.byteLength>=this._targetSize){n.writer.close();const{out:s}=n;n=newCar(r),yield{channel:n,out:s}}r=r.concat(o),n.size+=o.bytes.byteLength,n.writer.put(o);for(const[,s]of o.links())for await(const u of this._cars(s,r,n))n=u.channel,yield u;if(!n)throw new Error("missing CAR writer channel");yield{channel:n}}static async fromIterable(e,r,n){const o=await CarReader.fromIterable(e);return new TreewalkCarSplitter(o,r,n)}static async fromBlob(e,r,n){const o=await e.arrayBuffer(),s=await CarReader.fromBytes(new Uint8Array(o));return new TreewalkCarSplitter(s,r,n)}}function newCar(t){const e=Object.assign(CarWriter.create(t[0].cid),{size:t.reduce((r,n)=>r+n.bytes.byteLength,0)});for(const r of t)e.writer.put(r);return e}const fetch=globalThis.fetch,Blob$1=globalThis.Blob,File=globalThis.File,Blockstore=MemoryBlockStore,MAX_PUT_RETRIES=5,MAX_CONCURRENT_UPLOADS=3,MAX_CHUNK_SIZE=1024*1024*10;class Web3Storage{constructor({token:e,endpoint:r=new URL("https://api.web3.storage")}){this.token=e,this.endpoint=r}static headers(e){if(!e)throw new Error("missing token");return{Authorization:`Bearer ${e}`,"X-Client":"web3.storage/js"}}static async put({endpoint:e,token:r},n,{onRootCidReady:o,onStoredChunk:s,maxRetries:u=MAX_PUT_RETRIES,wrapWithDirectory:l=!0,name:h}={}){const d=new Blockstore;try{const{out:p,root:b}=await pack({input:Array.from(n).map(T=>({path:T.name,content:T.stream()})),blockstore:d,wrapWithDirectory:l,maxChunkSize:1048576,maxChildrenPerNode:1024});o&&o(b.toString());const _=await CarReader.fromIterable(p);return await Web3Storage.putCar({endpoint:e,token:r},_,{onStoredChunk:s,maxRetries:u,name:h})}finally{await d.close()}}static async putCar({endpoint:e,token:r},n,{name:o,onStoredChunk:s,maxRetries:u=MAX_PUT_RETRIES,decoders:l}={}){const h=MAX_CHUNK_SIZE,d=new URL("car",e);let p=Web3Storage.headers(r);o&&(p=Z(M({},p),{"X-Name":encodeURIComponent(o)}));const b=await n.getRoots();if(b[0]==null)throw new Error("missing root CID");if(b.length>1)throw new Error("too many roots");const _=b[0].toString(),T=new TreewalkCarSplitter(n,h,{decoders:l}),g=transform(MAX_CONCURRENT_UPLOADS,async B=>{const k=[];for await(const v of B)k.push(v);const R=new Blob$1(k,{type:"application/car"}),x=await pRetry$1(async()=>{const v=await fetch(d.toString(),{method:"POST",headers:p,body:R}),E=await v.json();if(!v.ok)throw new Error(E.message);if(E.cid!==_)throw new Error(`root CID mismatch, expected: ${_}, received: ${E.cid}`);return E.cid},{retries:u});return s&&s(R.size),x});for await(const B of g(T.cars()));return _}static async get({endpoint:e,token:r},n){const o=new URL(`car/${n}`,e),s=await fetch(o.toString(),{method:"GET",headers:Web3Storage.headers(r)});return toWeb3Response(s)}static async delete({endpoint:e,token:r},n){throw console.log("Not deleting",n,e,r),Error(".delete not implemented yet")}static async status({endpoint:e,token:r},n){const o=new URL(`status/${n}`,e),s=await fetch(o.toString(),{method:"GET",headers:Web3Storage.headers(r)});if(s.status!==404){if(!s.ok)throw new Error(s.statusText);return s.json()}}static async*list(e,{before:r=new Date().toISOString(),maxResults:n=1/0}={}){function o({endpoint:l,token:h},{before:d,size:p}){const b=new URLSearchParams({before:d,size:p.toString()}),_=new URL(`user/uploads?${b}`,l);return fetch(_.toString(),{method:"GET",headers:Z(M({},Web3Storage.headers(h)),{"Access-Control-Request-Headers":"Link"})})}let s=0;const u=n>100?100:n;for await(const l of paginator(o,e,{before:r,size:u})){if(!l.ok){const d=await l.json();throw new Error(`${l.status} ${l.statusText} ${d?"- "+d.message:""}`)}const h=await l.json();for(const d of h){if(++s>n)return;yield d}}}put(e,r){return Web3Storage.put(this,e,r)}putCar(e,r){return Web3Storage.putCar(this,e,r)}get(e){return Web3Storage.get(this,e)}delete(e){return Web3Storage.delete(this,e)}status(e){return Web3Storage.status(this,e)}list(e){return Web3Storage.list(this,e)}}async function toWeb3File({content:t,path:e,cid:r}){const n=[];for await(const s of t())n.push(s);const o=new File(n,toFilenameWithPath(e));return Object.assign(o,{cid:r.toString()})}function toFilenameWithPath(t){const e=t.indexOf("/");return e===-1?t:t.substring(e+1)}function toWeb3Response(t){const e=Object.assign(t,{unixFsIterator:async function*(){if(!t.ok)throw new Error(`Response was not ok: ${t.status} ${t.statusText} - Check for { "ok": false } on the Response object before calling .unixFsIterator`);if(!t.body)throw new Error("No body on response");const r=new Blockstore;try{for await(const n of unpackStream(t.body,{blockstore:r}))yield n}finally{await r.close()}},files:async()=>{if(!t.ok)throw new Error(`Response was not ok: ${t.status} ${t.statusText} - Check for { "ok": false } on the Response object before calling .files`);const r=[];for await(const n of e.unixFsIterator()){if(n.type==="directory")continue;const o=await toWeb3File(n);r.push(o)}return r}});return e}async function*paginator(t,e,r){let n=await t(e,r);yield n;let o=parseLinkHeader(n.headers.get("Link")||"");for(;o&&o.next;)n=await t(e,o.next),yield n,o=parseLinkHeader(n.headers.get("Link")||"")}var getRandomValues,rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&(getRandomValues=typeof crypto!="undefined"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto!="undefined"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!getRandomValues))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}var REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function validate(t){return typeof t=="string"&&REGEX.test(t)}var byteToHex=[];for(var i=0;i<256;++i)byteToHex.push((i+256).toString(16).substr(1));function stringify(t){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,r=(byteToHex[t[e+0]]+byteToHex[t[e+1]]+byteToHex[t[e+2]]+byteToHex[t[e+3]]+"-"+byteToHex[t[e+4]]+byteToHex[t[e+5]]+"-"+byteToHex[t[e+6]]+byteToHex[t[e+7]]+"-"+byteToHex[t[e+8]]+byteToHex[t[e+9]]+"-"+byteToHex[t[e+10]]+byteToHex[t[e+11]]+byteToHex[t[e+12]]+byteToHex[t[e+13]]+byteToHex[t[e+14]]+byteToHex[t[e+15]]).toLowerCase();if(!validate(r))throw TypeError("Stringified UUID is invalid");return r}function v4(t,e,r){t=t||{};var n=t.random||(t.rng||rng)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){r=r||0;for(var o=0;o<16;++o)e[r+o]=n[o];return e}return stringify(n)}export{SvelteComponent as S,Web3Storage as W,space as a,src_url_equal as b,attr as c,insert as d,element as e,append as f,detach as g,init as i,noop$2 as n,safe_not_equal as s,v4 as v};
